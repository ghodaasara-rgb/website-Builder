var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/fetchController.ts
__markAsModule(exports);
__export(exports, {
  FetchController: () => FetchController
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_directFetch = __toModule(require("./directFetch.cjs"));
var import_utils = __toModule(require("./utils.cjs"));
var FetchController = class {
  constructor(context, coreProxy) {
    this.killSwitchActivated = false;
    this.noOpActivated = false;
    this.controlledFetch = (request, init) => {
      if (this.killSwitchActivated) {
        return this.handleAbortError(request, "Kill switch was already enabled");
      }
      if (!this.abortController) {
        this.abortController = new AbortController();
      }
      const signal = this.abortController?.signal;
      const updatedInit = {
        ...init,
        headers: {...init?.headers, ...this.headers},
        signal
      };
      const fetchFunction = this.noOpActivated ? this.fetchNoOp(request, updatedInit) : this.fetchEndowment(request, updatedInit);
      const fetchPromise = fetchFunction.catch((error) => {
        const errorMsg = error.message || error;
        if (error && (errorMsg.startsWith("AbortError") || error?.stack.startsWith("AbortError"))) {
          return this.handleAbortError(request, error);
        } else {
          throw error;
        }
      });
      return fetchPromise;
    };
    this.activateKillSwitch = () => {
      this.killSwitchActivated = true;
      this.abortController?.abort("AbortError: Kill switch enabled");
      this.abortController = void 0;
    };
    this.deactivateKillSwitch = () => {
      this.killSwitchActivated = false;
    };
    this.activateNoOp = () => {
      this.noOpActivated = true;
    };
    this.deactivateNoOp = () => {
      this.noOpActivated = false;
    };
    this.setFetchRequestContext = (context) => {
      const {abortController, host, headers} = context;
      this.host = host;
      this.headers = headers;
      this.abortController = abortController;
    };
    this.coreProxy = coreProxy;
    this.setFetchRequestContext(context);
    this.fetchEndowment = this.createFetchEndowment();
  }
  handleAbortError(request, error) {
    const message = `${String(request)} request was killed. Either the request timed out or it was dispatched during SSR. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
    import_diagnostics.logger.warn({label: `Server-side Rendering`, message}, error);
    return Promise.resolve(new Response(message, {status: 500}));
  }
  fetchNoOp(request, init) {
    return new Promise((resolve) => {
      if (!init?.signal) {
        resolve(this.handleAbortError(request, new Error("RequestInit was not setup as expected")));
      } else if (init.signal.aborted) {
        resolve(this.handleAbortError(request, new Error("Request was already aborted")));
      } else {
        const abortHandler = (err) => {
          init?.signal?.removeEventListener("abort", abortHandler);
          resolve(this.handleAbortError(request, new Error("Not allowed: Request was dispatched during SSR", {cause: err})));
        };
        init.signal.addEventListener("abort", abortHandler);
      }
    });
  }
  createFetchEndowment() {
    return (request, init = {}) => {
      const {host: forwardedOrigin = "", coreProxy} = this;
      const {finalRequest, finalUrl} = (0, import_utils.getFinalRequest)(request, forwardedOrigin);
      if (coreProxy || forwardedOrigin && finalUrl.startsWith(forwardedOrigin)) {
        init.headers[import_directFetch.ROUTE_CORE_HEADER] = "true";
      }
      const hasCookies = this.headers && this.headers.Cookie ? "yes" : "no";
      import_diagnostics.logger.info({
        label: `pre ${import_instrumentation.ViewSpan.Fetch}`,
        message: `finalUrl: ${finalUrl}, hasCookies: ${hasCookies}`
      });
      return (0, import_instrumentation.getTracer)().trace({
        name: import_instrumentation.ViewSpan.Fetch,
        attributes: {
          url: finalUrl,
          fetchType: "cdn",
          forwardedOrigin,
          hasCookies
        }
      }, (span) => {
        const withTracing = (fetchPromise) => {
          return fetchPromise.then((res) => {
            res.url && span.setAttributes({url: res.url});
            span.setAttributes({statusCode: res.status});
            return res;
          }).catch((e) => {
            span.setAttributes({error: (0, import_diagnostics.stringifyError)(e)});
            throw e;
          });
        };
        init.headers = {...init.headers, ...(0, import_shared_utils.getTraceHeaders)({}, span)};
        if (coreProxy) {
          return withTracing((0, import_directFetch.fetchWithAgent)(request, init, forwardedOrigin, coreProxy, span));
        }
        return withTracing(fetch(finalRequest, init));
      });
    };
  }
};
