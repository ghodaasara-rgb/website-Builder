var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/renderer.ts
__markAsModule(exports);
__export(exports, {
  Renderer: () => Renderer,
  getRenderer: () => getRenderer
});
var import_lru_cache = __toModule(require("lru-cache"));
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_instrumentation = __toModule(require("@lwrjs/instrumentation"));
var import_utils = __toModule(require("./utils.cjs"));
var import_moduleLoader = __toModule(require("./moduleLoader.cjs"));
var import_serverBootstrapServices = __toModule(require("./serverBootstrapServices.cjs"));
var singleton;
function getRenderer(config, bundleRegistry, resourceRegistry) {
  if (!singleton) {
    singleton = new Renderer(config, bundleRegistry, resourceRegistry);
  }
  return singleton;
}
var Renderer = class {
  constructor(config, bundleRegistry, resourceRegistry) {
    this.globalCache = {};
    this.config = config;
    this.bundleRegistry = bundleRegistry;
    this.resourceRegistry = resourceRegistry;
    this.contextPerEnv = new import_lru_cache.LRUCache({
      max: 50,
      dispose: (_value, key) => {
        if ((0, import_shared_utils.isLambdaEnv)()) {
          import_diagnostics.logger.warn(`Bootstrap Context evicted from cache ${key}`);
        } else {
          import_diagnostics.logger.verbose(`Bootstrap Context evicted from cache ${key}`);
        }
      }
    });
    const taskPoolSize = 1;
    this.pendingRenders = new import_shared_utils.TaskPool(taskPoolSize);
  }
  async render(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR) {
    let result;
    if ((0, import_shared_utils.isLambdaEnv)() || process.env.SSR_TIMEOUT !== void 0) {
      let timerId;
      const abortController = new AbortController();
      const timeout = new Promise((_, reject) => {
        timerId = setTimeout(() => {
          const message = import_diagnostics.descriptions.APPLICATION.SSR_TIMEOUT(route.id, (0, import_utils.getRenderTimeout)());
          abortController.abort(`AbortError: ${message}`);
          reject(new import_diagnostics.LwrApplicationError(message));
        }, (0, import_utils.getRenderTimeout)());
      });
      result = await this.pendingRenders.execute(async () => {
        return Promise.race([
          timeout,
          this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR, abortController)
        ]);
      });
      clearTimeout(timerId);
    } else {
      result = await this.pendingRenders.execute(async () => {
        return this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR);
      });
    }
    return result;
  }
  async renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR = false, abortController) {
    const results = {};
    const warnings = [];
    const roots = Object.keys(components);
    const services = (0, import_utils.getServerBootstrapServices)(route);
    const reevaluateModules = (0, import_shared_utils.getFeatureFlags)().REEVALUATE_MODULES === true;
    let loader, bootstrapServiceEvaluationMap;
    try {
      let lwcEngine, serverBootstrapServices;
      ({bootstrapServiceEvaluationMap, loader, lwcEngine, serverBootstrapServices} = await this.createLoader(components, route, serverData, isFirstOf2PassSSR, services, runtimeEnvironment, runtimeParams, abortController));
      const componentModules = await this.loadAppCode(components, route, roots, loader);
      await this.executeDataServices(components, route, serverBootstrapServices, componentModules, serverData, results, warnings, runtimeEnvironment, runtimeParams);
      if (!route.bootstrap.ssr) {
        return {results, warnings, bundles: loader?.getBundles()};
      }
      loader?.getFetchController().enableNoOpFetch();
      for (const component of componentModules) {
        const {html} = await renderToString(lwcEngine.module, component, results[component.specifier].props);
        results[component.specifier].html = html;
      }
      return {results, warnings, bundles: loader?.getBundles()};
    } finally {
      loader?.getFetchController().disableNoOpFetch();
      loader?.getFetchController().enableFetchKillSwitch();
      if (!isFirstOf2PassSSR) {
        loader?.resetGlobalContext();
        if (reevaluateModules) {
          bootstrapServiceEvaluationMap?.delete(route.id);
          loader?.clearRegistry();
        }
      }
    }
  }
  async loadAppCode(components, route, roots, loader) {
    return await (0, import_instrumentation.getTracer)().trace({
      name: import_instrumentation.ViewSpan.LoadAppCode,
      attributes: {
        components: Object.keys(components).join(","),
        routeId: route.id
      }
    }, async (span) => {
      return import_instrumentation.cacheCountStore.startCacheContext(async () => {
        try {
          const ret = await Promise.all(roots.map((specifier) => loader?.load(specifier)));
          const context = import_instrumentation.cacheCountStore.getCache();
          if (context) {
            span.setAttributes(context);
          }
          return ret;
        } finally {
          import_instrumentation.cacheCountStore.resetCache();
        }
      });
    });
  }
  async executeDataServices(components, route, serverBootstrapServices, componentModules, serverData, results, warnings, runtimeEnvironment, runtimeParams) {
    return (0, import_instrumentation.getTracer)().trace({
      name: import_instrumentation.ViewSpan.ExecuteServices,
      attributes: {
        components: Object.keys(components).join(","),
        routeId: route.id
      }
    }, async () => {
      if (serverBootstrapServices) {
        const cookies = route.bootstrap.includeCookiesForSSR && runtimeParams.cookie ? (0, import_shared_utils.cookieStringToObject)(runtimeParams.cookie) : null;
        serverBootstrapServices.evaluateRequestHooks({cookies});
      }
      for (const component of componentModules) {
        const {props} = components[component.specifier];
        if (!component.module.getServerData) {
          results[component.specifier] = {props};
          continue;
        }
        const context = {
          props,
          url: runtimeParams.url,
          params: runtimeParams.params || {},
          query: runtimeParams.query || {},
          locale: runtimeParams.locale || runtimeEnvironment.i18n?.defaultLocale,
          basePath: runtimeParams.basePath || runtimeEnvironment.basePath,
          crossRequestCache: this.globalCache
        };
        const data = await getServerData(component, context, serverData);
        if (data) {
          results[component.specifier] = data;
        }
        data.warnings && warnings.push(...data.warnings);
      }
      if (serverBootstrapServices) {
        serverBootstrapServices.evaluateServerDataHooks(serverData);
      }
    });
  }
  async createLoader(components, route, serverData, isFirstOf2PassSSR, services, runtimeEnvironment, runtimeParams, abortController) {
    return (0, import_instrumentation.getTracer)().trace({
      name: import_instrumentation.ViewSpan.CreateLoader,
      attributes: {
        components: Object.keys(components).join(","),
        routeId: route.id
      }
    }, async (span) => {
      return import_instrumentation.cacheCountStore.startCacheContext(async () => {
        try {
          const bootstrapContext = this.getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR, abortController);
          const bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
          const loader = await bootstrapContext.loader;
          loader.clearBundles();
          const fetchController = loader.getFetchController();
          this.resetFetchController(fetchController, runtimeParams, route, abortController);
          const engineServerSpecifier = (0, import_shared_utils.getSpecifier)({
            specifier: (0, import_shared_utils.getFeatureFlags)().SSR_COMPILER_ENABLED ? "@lwc/ssr-runtime" : "@lwc/engine-server",
            version: route.bootstrap.lwcVersion
          });
          const lwcEngine = await loader?.load(engineServerSpecifier, ["lwc"]);
          const is2ndPass = route.contentTemplate && route.contentTemplate.component && !isFirstOf2PassSSR;
          const needsBootstrap = !bootstrapServiceEvaluationMap?.has(route.id);
          let serverBootstrapServices;
          if (!is2ndPass || needsBootstrap) {
            bootstrapServiceEvaluationMap?.set(route.id, true);
            const serviceModules = await Promise.all(services.map((specifier) => loader?.load(specifier)));
            serverBootstrapServices = (0, import_serverBootstrapServices.createServerBootstrapServices)(loader);
            for (const service of serviceModules) {
              await (0, import_serverBootstrapServices.evaluateServerBootstrapModule)(service, serverBootstrapServices.serviceAPI);
            }
          }
          const ret = {
            bootstrapServiceEvaluationMap,
            loader,
            lwcEngine,
            serverBootstrapServices
          };
          const context = import_instrumentation.cacheCountStore.getCache();
          if (context) {
            span.setAttributes(context);
          }
          return ret;
        } finally {
          import_instrumentation.cacheCountStore.resetCache();
        }
      });
    });
  }
  resetFetchController(fetchController, runtimeParams, route, abortController) {
    fetchController.disableFetchKillSwitch();
    const baseHeaders = {
      [import_shared_utils.REQUEST_DEPTH_HEADER]: runtimeParams.requestDepth ?? "0",
      ...(0, import_shared_utils.getTraceHeaders)(runtimeParams)
    };
    fetchController.setFetchRequestContext({
      host: runtimeParams.host,
      headers: route.bootstrap.includeCookiesForSSR ? {Cookie: runtimeParams.cookie, ...baseHeaders} : baseHeaders,
      abortController
    });
  }
  getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR, abortController) {
    let loader, bootstrapServiceEvaluationMap;
    const envContext = (0, import_shared_utils.buildEnvironmentContext)(runtimeParams);
    const versions = {lwrVersion: route.bootstrap?.lwrVersion, lwcVersion: route.bootstrap?.lwcVersion};
    const contextCacheKey = (0, import_shared_utils.getCacheKeyFromJson)({envContext, versions});
    const bootstrapContext = this.contextPerEnv.get(contextCacheKey);
    if (!bootstrapContext || (0, import_shared_utils.isLocalDev)() && isFirstOf2PassSSR || (0, import_shared_utils.getFeatureFlags)().SSR_LOADER_PER_REQUEST) {
      loader = (0, import_moduleLoader.createModuleLoader)(this.config, this.resourceRegistry, this.bundleRegistry, runtimeEnvironment, runtimeParams, serverData, route.bootstrap, abortController);
      bootstrapServiceEvaluationMap = new Map();
      this.contextPerEnv.set(contextCacheKey, {
        loader,
        bootstrapServiceEvaluationMap
      });
    } else {
      loader = bootstrapContext.loader;
      bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
    }
    return {
      loader,
      bootstrapServiceEvaluationMap
    };
  }
};
function getServerData(component, context, serverData) {
  return (0, import_instrumentation.getTracer)().trace({
    name: import_instrumentation.ViewSpan.GetServerData,
    attributes: {specifier: component.specifier}
  }, async (span) => {
    try {
      const data = await component.module.getServerData(context);
      Object.assign(serverData, data.props);
      if (data.warnings) {
        const warnings = data.warnings.map((w) => (0, import_diagnostics.stringifyError)(w)).join(", ");
        span.setAttributes({warnings});
      }
      const dataProviderMetrics = data.props?.metrics?.dataProvider;
      if (dataProviderMetrics) {
        const {success: dataProviderSuccess, warnings: dataProviderWarnings} = dataProviderMetrics;
        if (dataProviderSuccess && dataProviderSuccess.length > 0) {
          span.setAttributes({dataProviderSuccess});
        }
        if (dataProviderWarnings && dataProviderWarnings.length > 0) {
          span.setAttributes({dataProviderWarnings});
        }
      }
      if (data.props?.metrics) {
        delete data.props.metrics;
      }
      return data;
    } catch (e) {
      if (e instanceof import_diagnostics.LwrError)
        throw e;
      const statusError = e;
      if (typeof statusError.status === "number") {
        throw new import_diagnostics.LwrStatusError(statusError.message, statusError.status, statusError.headers);
      }
      if (e.dataProviderFailed) {
        const dataProviderFailed = e.dataProviderFailed;
        if (dataProviderFailed.length > 0) {
          span.setAttributes({dataProviderFailed});
        }
      }
      throw new import_diagnostics.LwrApplicationError(`Error in "getServerData" for "${component.specifier}": ${(0, import_diagnostics.stringifyError)(e)}`);
    }
  });
}
async function renderToString(engine, component, props) {
  const isSSRv2 = (0, import_shared_utils.getFeatureFlags)().SSR_COMPILER_ENABLED || false;
  return (0, import_instrumentation.getTracer)().trace({
    name: import_instrumentation.ViewSpan.RenderComponent,
    attributes: {specifier: component.specifier, isSSRv2}
  }, async () => {
    try {
      const elementName = (0, import_shared_utils.moduleSpecifierToKebabCase)(component.specifier);
      const moduleDefault = component.module.default;
      const html = isSSRv2 ? await engine.renderComponent(elementName, moduleDefault, props, elementName, "sync") : engine.renderComponent(elementName, moduleDefault, props);
      return {html};
    } catch (e) {
      if (e instanceof import_diagnostics.LwrError)
        throw e;
      const error = Object(e);
      const message = error.message ?? (0, import_diagnostics.stringifyError)(e);
      const detailedMessage = error.wcStack ? "An error occurred during server-side rendering for component stack: " + error.wcStack + ". Error was: " + message : `An error occurred during server-side rendering "${component.specifier}": ` + message;
      throw new import_diagnostics.LwrApplicationError(detailedMessage);
    }
  });
}
