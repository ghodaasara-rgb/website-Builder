var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/lwc-ssr/src/directFetch.ts
__markAsModule(exports);
__export(exports, {
  ROUTE_CORE_HEADER: () => ROUTE_CORE_HEADER,
  fetchWithAgent: () => fetchWithAgent
});
var import_undici = __toModule(require("undici"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_utils = __toModule(require("./utils.cjs"));
var CORE_CLIENTS = new Map();
var ROUTE_CORE_HEADER = "x-sfdc-route-core";
async function fetchWithAgent(request, init, forwardedOrigin, coreProxy, span) {
  let {origin, servername} = coreProxy;
  const {finalUrl} = (0, import_utils.getFinalRequest)(request, origin.startsWith("http") ? origin : forwardedOrigin);
  const forwardedHostname = (0, import_shared_utils.toHostname)(forwardedOrigin);
  const hostHeader = coreProxy.host ?? forwardedHostname;
  const ENHANCED_DOMAIN_TLD = ".site.com";
  const MY_DOMAIN_TLD = ".salesforce.com";
  if (forwardedHostname.endsWith(ENHANCED_DOMAIN_TLD)) {
    const myHostname = forwardedHostname.slice(0, -ENHANCED_DOMAIN_TLD.length) + MY_DOMAIN_TLD;
    origin = "https://" + myHostname;
    servername = myHostname;
  } else if (origin.startsWith(".")) {
    origin = "https://" + forwardedHostname + origin;
  }
  const urlParts = new URL(finalUrl);
  const path = urlParts.pathname + urlParts.search;
  const url = origin + path;
  const proxyStr = coreProxy ? JSON.stringify(coreProxy) : "none";
  span.setAttributes({
    fetchType: "direct",
    url,
    coreProxy: proxyStr,
    coreUrl: url,
    coreHostHeader: hostHeader,
    coreServername: servername
  });
  let client = CORE_CLIENTS.get(origin);
  if (!client) {
    client = new import_undici.Pool(origin, {
      connections: parseInt(process.env.CLIENT_CONNECTION_LIMIT ?? "100", 10),
      keepAliveTimeout: 3e4
    });
    CORE_CLIENTS.set(origin, client);
  }
  return client.request({
    ...init,
    method: init.method || "GET",
    path,
    headers: {...init?.headers, Host: hostHeader},
    servername
  }).then(async (res) => {
    span.setAttributes({coreStatusCode: res.statusCode});
    const bodyBuffer = await res.body.arrayBuffer();
    const body = res.statusCode === 204 || res.statusCode === 205 ? null : bodyBuffer;
    const headers = new Headers();
    for (const [key, value] of Object.entries(res.headers)) {
      if (!value)
        continue;
      const values = Array.isArray(value) ? value : [value];
      values.forEach((v) => headers.append(key, v));
    }
    return new Response(body, {status: res.statusCode, headers});
  });
}
