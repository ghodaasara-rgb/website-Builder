// TODO: investigate perf impact W-16056356
import { LRUCache } from 'lru-cache';
import { LwrApplicationError, LwrError, LwrStatusError, descriptions, logger, stringifyError, } from '@lwrjs/diagnostics';
import { REQUEST_DEPTH_HEADER, TaskPool, buildEnvironmentContext, cookieStringToObject, getCacheKeyFromJson, getFeatureFlags, getSpecifier, getTraceHeaders, isLambdaEnv, isLocalDev, moduleSpecifierToKebabCase, } from '@lwrjs/shared-utils';
import { ViewSpan, cacheCountStore, getTracer } from '@lwrjs/instrumentation';
import { getServerBootstrapServices, getRenderTimeout } from './utils.js';
import { createModuleLoader } from './moduleLoader.js';
import { createServerBootstrapServices, evaluateServerBootstrapModule, } from './serverBootstrapServices.js';
let singleton;
/**
 * Get a renderer singleton
 *
 * @param bundleRegistry
 * @param resourceRegistry
 * @returns singleton
 */
export function getRenderer(config, bundleRegistry, resourceRegistry) {
    // todo: reset singleton on file change for local dev
    if (!singleton) {
        singleton = new Renderer(config, bundleRegistry, resourceRegistry);
    }
    return singleton;
}
export class Renderer {
    config;
    bundleRegistry;
    resourceRegistry;
    contextPerEnv;
    pendingRenders;
    globalCache = {};
    constructor(config, bundleRegistry, resourceRegistry) {
        this.config = config;
        this.bundleRegistry = bundleRegistry;
        this.resourceRegistry = resourceRegistry;
        // Prevent number of cached contexts from growing unbounded.
        // In reality, the number of env permutations should be relatively small
        this.contextPerEnv = new LRUCache({
            max: 50,
            dispose: (_value, key) => {
                if (isLambdaEnv()) {
                    logger.warn(`Bootstrap Context evicted from cache ${key}`);
                }
                else {
                    logger.verbose(`Bootstrap Context evicted from cache ${key}`);
                }
            },
        });
        // TODO: remove the task pool altogether once W-16047359 is resolved.
        // Until the above issues are resolved, we can only handle one request at a time.
        // Since Lambda's can only handle 1 request at a time anyways, this is fine for now.
        // const taskPoolSize = getFeatureFlags().SINGLE_RENDER_MODE ? 1 : 15;
        const taskPoolSize = 1;
        this.pendingRenders = new TaskPool(taskPoolSize);
    }
    /**
     * Render components to HTML strings
     *
     * @remarks
     * The rendering flow is as follows:
     *  1. invoke `getServerData`
     *  2. execute the route's SSR bootstrap services
     *  3. render the component to HTML
     *
     * @param components - group of components to render
     * @param route - route configuration
     * @param runtimeEnvironment - environment context
     * @param runtimeParams - request context
     * @param serverData - render data TODO serverData is modified (add test?)
     * @returns render results per component
     */
    async render(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR) {
        let result;
        // Only use a timeout when running in a lambda environment or if we've manually specified a timeout (for local testing purposes)
        if (isLambdaEnv() || process.env.SSR_TIMEOUT !== undefined) {
            let timerId;
            const abortController = new AbortController();
            const timeout = new Promise((_, reject) => {
                timerId = setTimeout(() => {
                    const message = descriptions.APPLICATION.SSR_TIMEOUT(route.id, getRenderTimeout());
                    abortController.abort(`AbortError: ${message}`);
                    reject(new LwrApplicationError(message));
                }, getRenderTimeout());
            });
            result = (await this.pendingRenders.execute(async () => {
                return Promise.race([
                    timeout,
                    // todo: abort the render if timeout occurs
                    this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR, abortController),
                ]);
            }));
            clearTimeout(timerId);
        }
        else {
            result = (await this.pendingRenders.execute(async () => {
                return this.renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR);
            }));
        }
        return result;
    }
    async renderComponents(components, route, runtimeEnvironment, runtimeParams, serverData = {}, isFirstOf2PassSSR = false, abortController) {
        const results = {};
        const warnings = [];
        const roots = Object.keys(components);
        const services = getServerBootstrapServices(route);
        // For LWR@MRT, module re-evaluation is enabled by default
        const reevaluateModules = getFeatureFlags().REEVALUATE_MODULES === true;
        // `SINGLE_RENDER_MODE` forces local preview of LWR@MRT apps to only handle
        // one request at a time. This is required until our fetch endowment (W-16047359) is updated
        // to be able to handle multiple concurrent requests.
        // const singleRenderMode = getFeatureFlags().SINGLE_RENDER_MODE;
        let loader, bootstrapServiceEvaluationMap;
        try {
            // We want a new context (and cache it for re-use) for each LWR env context.
            // E.g. if we `env.basePath: '/'` vs `env.basePath: '/foo` will result
            // in the new contexts created and used for by the renderer.
            //
            // When `REEVALUATE_MODULES` is enabled, we only have a single context/loader, regardless of env
            let lwcEngine, serverBootstrapServices;
            ({ bootstrapServiceEvaluationMap, loader, lwcEngine, serverBootstrapServices } =
                await this.createLoader(components, route, serverData, isFirstOf2PassSSR, services, runtimeEnvironment, runtimeParams, abortController));
            // load root component modules (and dependencies)
            const componentModules = await this.loadAppCode(components, route, roots, loader);
            // Execute Services that fetch application data
            await this.executeDataServices(components, route, serverBootstrapServices, componentModules, serverData, results, warnings, runtimeEnvironment, runtimeParams);
            // exit early when preloading data
            if (!route.bootstrap.ssr) {
                return { results, warnings, bundles: loader?.getBundles() };
            }
            // Assumed in SINGLE_RENDER mode to enable no-op during renderCmp phase.
            loader?.getFetchController().enableNoOpFetch();
            // render components
            for (const component of componentModules) {
                // eslint-disable-next-line no-await-in-loop
                const { html } = await renderToString(lwcEngine.module, component, results[component.specifier].props);
                results[component.specifier].html = html;
            }
            return { results, warnings, bundles: loader?.getBundles() };
        }
        finally {
            // Assumed in SINGLE_RENDER mode
            loader?.getFetchController().disableNoOpFetch();
            // activate fetch controller kill switch
            loader?.getFetchController().enableFetchKillSwitch();
            // At the end of 2-pass SSR, clean up for the next page render
            if (!isFirstOf2PassSSR) {
                // since we have a single global context that is maintained across page renders,
                // we need to clean it up so that state such as globalThis.LWR.serverData is not preserved
                loader?.resetGlobalContext();
                // When `REEVALUATE_MODULES` is enabled, we clear the loader's module registry + bootstrap services
                // at the end of every render so that module state is not preserved.
                if (reevaluateModules) {
                    // clear bootstrap services so that next page render can call bootstrap services again
                    bootstrapServiceEvaluationMap?.delete(route.id);
                    loader?.clearRegistry();
                }
            }
        }
    }
    async loadAppCode(components, route, roots, loader) {
        return await getTracer().trace({
            name: ViewSpan.LoadAppCode,
            attributes: {
                components: Object.keys(components).join(','),
                routeId: route.id,
            },
        }, async (span) => {
            // Set up the initial context with a counter
            return cacheCountStore.startCacheContext(async () => {
                try {
                    // Start AsyncLocalStorage and execute tracing within this context
                    const ret = await Promise.all(roots.map((specifier) => loader?.load(specifier)));
                    // Add cache metrics
                    const context = cacheCountStore.getCache();
                    // Attach the final count to the span if context is available
                    if (context) {
                        span.setAttributes(context);
                    }
                    return ret;
                }
                finally {
                    // Ensure cache is reset, regardless of success or error
                    cacheCountStore.resetCache();
                }
            });
        });
    }
    /**
     * Run bootstrap services and fetch server data
     */
    async executeDataServices(components, route, serverBootstrapServices, componentModules, serverData, results, warnings, runtimeEnvironment, runtimeParams) {
        return getTracer().trace({
            name: ViewSpan.ExecuteServices,
            attributes: {
                components: Object.keys(components).join(','),
                routeId: route.id,
            },
        }, async () => {
            if (serverBootstrapServices) {
                // run the request hook before `getServerData` and other bootstrap hooks
                const cookies = route.bootstrap.includeCookiesForSSR && runtimeParams.cookie
                    ? cookieStringToObject(runtimeParams.cookie)
                    : null;
                serverBootstrapServices.evaluateRequestHooks({ cookies });
            }
            // get server data
            for (const component of componentModules) {
                const { props } = components[component.specifier];
                if (!component.module.getServerData) {
                    results[component.specifier] = { props };
                    continue;
                }
                const context = {
                    props,
                    url: runtimeParams.url,
                    params: runtimeParams.params || {},
                    query: runtimeParams.query || {},
                    locale: runtimeParams.locale || runtimeEnvironment.i18n?.defaultLocale,
                    basePath: runtimeParams.basePath || runtimeEnvironment.basePath,
                    crossRequestCache: this.globalCache,
                };
                // eslint-disable-next-line
                const data = await getServerData(component, context, serverData);
                if (data) {
                    results[component.specifier] = data;
                }
                data.warnings && warnings.push(...data.warnings);
            }
            if (serverBootstrapServices) {
                // now that we have server data, run the server data hooks
                serverBootstrapServices.evaluateServerDataHooks(serverData);
            }
        });
    }
    /**
     * Create and initialize the loader and LWC engine for SSR
     */
    async createLoader(components, route, serverData, isFirstOf2PassSSR, services, runtimeEnvironment, runtimeParams, abortController) {
        return getTracer().trace({
            name: ViewSpan.CreateLoader,
            attributes: {
                components: Object.keys(components).join(','),
                routeId: route.id,
            },
        }, async (span) => {
            // Set up the initial context with a counter
            return cacheCountStore.startCacheContext(async () => {
                try {
                    // Start AsyncLocalStorage and execute tracing within this context
                    const bootstrapContext = this.getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR, abortController);
                    const bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
                    // Wait for the loader to be initialized
                    const loader = await bootstrapContext.loader;
                    loader.clearBundles(); // clear between each render()
                    // reset/init the fetch controller between page renders
                    const fetchController = loader.getFetchController();
                    this.resetFetchController(fetchController, runtimeParams, route, abortController);
                    // load and alias the LWC server engine
                    // this MUST be done first in case bootstrap services depend on LWC
                    const engineServerSpecifier = getSpecifier({
                        specifier: getFeatureFlags().SSR_COMPILER_ENABLED
                            ? '@lwc/ssr-runtime'
                            : '@lwc/engine-server',
                        version: route.bootstrap.lwcVersion,
                    });
                    const lwcEngine = await loader?.load(engineServerSpecifier, ['lwc']);
                    // Run bootstrap services once per page render. This is important for serverData changes between requests for the same route.
                    const is2ndPass = route.contentTemplate &&
                        route.contentTemplate.component &&
                        !isFirstOf2PassSSR;
                    const needsBootstrap = !bootstrapServiceEvaluationMap?.has(route.id);
                    let serverBootstrapServices;
                    if (!is2ndPass || needsBootstrap) {
                        bootstrapServiceEvaluationMap?.set(route.id, true);
                        // bootstrap services MUST load/evaluate before any module resolution (except LWC)
                        // this ensures any loader `resolveHook` is registered first
                        const serviceModules = await Promise.all(services.map((specifier) => loader?.load(specifier)));
                        // set up the server-side Service API for the loader
                        serverBootstrapServices = createServerBootstrapServices(loader);
                        // evaluate the default function from each service module, passing in the Service API
                        // this is where the loader and server data hooks are set
                        for (const service of serviceModules) {
                            // eslint-disable-next-line
                            await evaluateServerBootstrapModule(service, serverBootstrapServices.serviceAPI);
                        }
                    }
                    const ret = {
                        bootstrapServiceEvaluationMap,
                        loader,
                        lwcEngine,
                        serverBootstrapServices,
                    };
                    // Add cache metrics
                    const context = cacheCountStore.getCache();
                    // Attach the final count to the span if context is available
                    if (context) {
                        span.setAttributes(context);
                    }
                    return ret;
                }
                finally {
                    // Ensure cache is reset, regardless of success or error
                    cacheCountStore.resetCache();
                }
            });
        });
    }
    resetFetchController(fetchController, runtimeParams, route, abortController) {
        // Re-enable fetch that was disabled at the end of the previous page render via `enableFetchKillSwitch`
        fetchController.disableFetchKillSwitch();
        const baseHeaders = {
            [REQUEST_DEPTH_HEADER]: runtimeParams.requestDepth ?? '0',
            ...getTraceHeaders(runtimeParams),
        };
        fetchController.setFetchRequestContext({
            host: runtimeParams.host,
            headers: route.bootstrap.includeCookiesForSSR
                ? { Cookie: runtimeParams.cookie, ...baseHeaders }
                : baseHeaders,
            abortController,
        });
    }
    getCachedBootstrapContext(route, runtimeEnvironment, runtimeParams, serverData, isFirstOf2PassSSR, abortController) {
        let loader, bootstrapServiceEvaluationMap;
        // when `REEEVALUTE_MODULES` is true, we only have a single context/loader, regardless of the env
        // We need a new context every time we change LWR contexts that modules depend on,
        // because the module needs to be *re-generated* with the new context values.
        //
        // On the Salesforce platform, this is *only* needed for label modules (depends on runtimeParams.locale),
        // and the `lwr/environment` module (depends on multiple runtimeParams).
        //
        // North star, we want to avoid runtime generated modules. Do NOT add additional dependencies
        // unless absolutely necessary.
        const envContext = buildEnvironmentContext(runtimeParams);
        const versions = { lwrVersion: route.bootstrap?.lwrVersion, lwcVersion: route.bootstrap?.lwcVersion };
        const contextCacheKey = getCacheKeyFromJson({ envContext, versions });
        const bootstrapContext = this.contextPerEnv.get(contextCacheKey);
        // Note: we can avoid creating a new context for local dev
        // if we update the loader to allow module redefines during local dev
        if (!bootstrapContext ||
            (isLocalDev() && isFirstOf2PassSSR) ||
            getFeatureFlags().SSR_LOADER_PER_REQUEST) {
            loader = createModuleLoader(this.config, this.resourceRegistry, this.bundleRegistry, runtimeEnvironment, runtimeParams, serverData, route.bootstrap, abortController);
            bootstrapServiceEvaluationMap = new Map();
            this.contextPerEnv.set(contextCacheKey, {
                loader,
                bootstrapServiceEvaluationMap,
            });
        }
        else {
            loader = bootstrapContext.loader;
            bootstrapServiceEvaluationMap = bootstrapContext.bootstrapServiceEvaluationMap;
        }
        return {
            loader: loader,
            bootstrapServiceEvaluationMap,
        };
    }
}
/**
 *
 * @param component
 * @param context
 * @param serverData modifies server data
 * @returns
 */
function getServerData(component, context, serverData) {
    return getTracer().trace({
        name: ViewSpan.GetServerData,
        attributes: { specifier: component.specifier },
    }, async (span) => {
        try {
            const data = await component.module.getServerData(context);
            Object.assign(serverData, data.props);
            if (data.warnings) {
                const warnings = data.warnings.map((w) => stringifyError(w)).join(', ');
                span.setAttributes({ warnings });
            }
            // Add data provider lists as span attributes (extracted from response)
            const dataProviderMetrics = data.props?.metrics?.dataProvider;
            if (dataProviderMetrics) {
                const { success: dataProviderSuccess, warnings: dataProviderWarnings } = dataProviderMetrics;
                if (dataProviderSuccess && dataProviderSuccess.length > 0) {
                    span.setAttributes({ dataProviderSuccess });
                }
                if (dataProviderWarnings && dataProviderWarnings.length > 0) {
                    span.setAttributes({ dataProviderWarnings });
                }
            }
            // Remove metrics from the response after processing
            if (data.props?.metrics) {
                delete data.props.metrics;
            }
            return data;
        }
        catch (e) {
            if (e instanceof LwrError)
                throw e;
            // getServerData cannot import the LwrStatusError from "@lwrjs/dianostics", since it's a client code
            // Once getServerData is decoupled from root components (TD-0187092), then it can import from "@lwrjs/*" server modules
            const statusError = e;
            if (typeof statusError.status === 'number') {
                throw new LwrStatusError(statusError.message, statusError.status, statusError.headers);
            }
            // Check if this error has dataProviderFailed attached
            if (e.dataProviderFailed) {
                const dataProviderFailed = e.dataProviderFailed;
                if (dataProviderFailed.length > 0) {
                    span.setAttributes({ dataProviderFailed });
                }
            }
            throw new LwrApplicationError(`Error in "getServerData" for "${component.specifier}": ${stringifyError(e)}`);
        }
    });
}
async function renderToString(engine, component, props) {
    const isSSRv2 = getFeatureFlags().SSR_COMPILER_ENABLED || false;
    return getTracer().trace({
        name: ViewSpan.RenderComponent,
        attributes: { specifier: component.specifier, isSSRv2 },
    }, async () => {
        try {
            const elementName = moduleSpecifierToKebabCase(component.specifier);
            const moduleDefault = component.module.default;
            const html = isSSRv2
                ? // serverSideRenderComponent(tagName: string, Component: ComponentWithGenerateMarkup, props: Properties = {}, styleDedupe: boolean | string = true, mode: CompilationMode = DEFAULT_SSR_MODE / 'sync'
                    await engine.renderComponent(elementName, moduleDefault, props, elementName, 'sync')
                : engine.renderComponent(elementName, moduleDefault, props);
            return { html };
        }
        catch (e) {
            if (e instanceof LwrError)
                throw e;
            const error = Object(e);
            // add the LWC rendering stack to the error message
            const message = error.message ?? stringifyError(e);
            const detailedMessage = error.wcStack
                ? 'An error occurred during server-side rendering for component stack: ' +
                    error.wcStack +
                    '. Error was: ' +
                    message
                : `An error occurred during server-side rendering "${component.specifier}": ` + message;
            throw new LwrApplicationError(detailedMessage);
        }
    });
}
//# sourceMappingURL=renderer.js.map