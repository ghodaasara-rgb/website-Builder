import { logger, stringifyError } from '@lwrjs/diagnostics';
import { getTracer, ViewSpan } from '@lwrjs/instrumentation';
import { getTraceHeaders } from '@lwrjs/shared-utils';
import { ROUTE_CORE_HEADER, fetchWithAgent } from './directFetch.js';
import { getFinalRequest } from './utils.js';
/**
 * During SSR a context is created with a new fetchController. At this point any fetches work as expected in this context.
 *
 * Right before renderComponents we call activateNoOp. At this point any new fetch calls in this context result in a no-op
 * fetch waiting to be aborted.
 *
 * When SSR for this request is complete we call activateKillSwitch which aborts any pending fetch calls in this context.
 * Any new fetch calls (i.e. from other async function calls) would be immediately aborted.
 */
export class FetchController {
    killSwitchActivated = false;
    noOpActivated = false;
    abortController;
    headers;
    host;
    coreProxy;
    fetchEndowment;
    constructor(context, coreProxy) {
        this.coreProxy = coreProxy;
        this.setFetchRequestContext(context);
        this.fetchEndowment = this.createFetchEndowment();
    }
    controlledFetch = (request, init) => {
        if (this.killSwitchActivated) {
            return this.handleAbortError(request, 'Kill switch was already enabled');
        }
        if (!this.abortController) {
            this.abortController = new AbortController();
        }
        const signal = this.abortController?.signal;
        // Ensure the init object exists and then add the signal to it.
        const updatedInit = {
            ...init,
            headers: { ...init?.headers, ...this.headers },
            signal,
        };
        const fetchFunction = this.noOpActivated
            ? this.fetchNoOp(request, updatedInit)
            : this.fetchEndowment(request, updatedInit);
        const fetchPromise = fetchFunction.catch((error) => {
            // Check if the error is an AbortError
            const errorMsg = error.message || error;
            if (error && (errorMsg.startsWith('AbortError') || error?.stack.startsWith('AbortError'))) {
                return this.handleAbortError(request, error);
            }
            else {
                // Re-throw the error if it's not an AbortError
                throw error;
            }
        });
        return fetchPromise;
    };
    /**
     * After SSR is complete the kill switch will abort any pending fetch requests.
     */
    activateKillSwitch = () => {
        this.killSwitchActivated = true;
        this.abortController?.abort('AbortError: Kill switch enabled');
        this.abortController = undefined;
    };
    deactivateKillSwitch = () => {
        this.killSwitchActivated = false;
    };
    /**
     * During SSR renderComponent (which is synchronous) Do not even call any fetch requests
     * since they would not complete before SSR is done.
     */
    activateNoOp = () => {
        this.noOpActivated = true;
    };
    deactivateNoOp = () => {
        this.noOpActivated = false;
    };
    setFetchRequestContext = (context) => {
        const { abortController, host, headers } = context;
        this.host = host;
        this.headers = headers;
        this.abortController = abortController;
    };
    handleAbortError(request, error) {
        const message = `${String(request)} request was killed. Either the request timed out or it was dispatched during SSR. Async processes are not supported during SSR. For more information, see: https://developer.salesforce.com/docs/platform/lwr/guide/lwr-configure-component-ssr.html.`;
        logger.warn({ label: `Server-side Rendering`, message }, error);
        // Return a response to indicate kill switch
        return Promise.resolve(new Response(message, { status: 500 }));
    }
    /**
     * Create a fetch API that never calls a request.
     * This is not expected to be called without an AbortController setup.
     */
    fetchNoOp(request, init) {
        return new Promise((resolve) => {
            if (!init?.signal) {
                // This should not happen?  This is only called internally to the class and we setup an abort controller.
                resolve(this.handleAbortError(request, new Error('RequestInit was not setup as expected')));
            }
            else if (init.signal.aborted) {
                // The request was already aborted go ahead and return the abort error
                resolve(this.handleAbortError(request, new Error('Request was already aborted')));
            }
            else {
                // Wait until fetches are aborted to resolve with an abort error
                const abortHandler = (err) => {
                    init?.signal?.removeEventListener('abort', abortHandler);
                    // Resolve the fetch
                    resolve(this.handleAbortError(request, new Error('Not allowed: Request was dispatched during SSR', { cause: err })));
                };
                init.signal.addEventListener('abort', abortHandler);
            }
        });
    }
    createFetchEndowment() {
        return (request, init = {}) => {
            const { host: forwardedOrigin = '', coreProxy } = this;
            const { finalRequest, finalUrl } = getFinalRequest(request, forwardedOrigin);
            if (coreProxy || (forwardedOrigin && finalUrl.startsWith(forwardedOrigin))) {
                // hint for the CDN that the request is targeted to Core
                init.headers[ROUTE_CORE_HEADER] = 'true';
            }
            const hasCookies = this.headers && this.headers.Cookie ? 'yes' : 'no';
            logger.info({
                label: `pre ${ViewSpan.Fetch}`,
                message: `finalUrl: ${finalUrl}, hasCookies: ${hasCookies}`,
            });
            return getTracer().trace(
            // fetchType is one of ['cdn' (default), 'direct']
            // Default URL to  final URL if successful addInfoToSpan will replace with response.url
            {
                name: ViewSpan.Fetch,
                attributes: {
                    url: finalUrl,
                    fetchType: 'cdn',
                    forwardedOrigin,
                    hasCookies,
                },
            }, (span) => {
                // this trace will NOT fail if fetch fails; it is meant to log the URLs fetched from the server
                // the fetch caller (ie: getServerData) should handle the error if response.ok is false
                // if the caller throws the fetch error, then it will be surfaced in the PARENT traces:
                // lwr.view.ssr.fetch (this) > lwr.view.ssr > lwr.view.ssr.island > lwr.view.render > lwr.handle.view
                const withTracing = (fetchPromise) => {
                    return fetchPromise
                        .then((res) => {
                        // add attributes to the trace which are only available post-fetch
                        res.url && span.setAttributes({ url: res.url }); // res.url is '' with undici
                        span.setAttributes({ statusCode: res.status });
                        return res;
                    })
                        .catch((e) => {
                        // add error to the trace
                        span.setAttributes({ error: stringifyError(e) });
                        throw e;
                    });
                };
                // add tracing headers based on span values
                init.headers = { ...init.headers, ...getTraceHeaders({}, span) };
                if (coreProxy) {
                    return withTracing(fetchWithAgent(request, init, forwardedOrigin, coreProxy, span));
                }
                return withTracing(fetch(finalRequest, init));
            });
        };
    }
}
//# sourceMappingURL=fetchController.js.map