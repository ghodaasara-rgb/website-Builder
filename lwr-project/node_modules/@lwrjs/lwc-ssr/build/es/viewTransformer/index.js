import { descriptions, logger, LwrApplicationError, LwrError, stringifyError } from '@lwrjs/diagnostics';
import { ViewSpan, getTracer } from '@lwrjs/instrumentation';
import { HYDRATE_DIRECTIVE, addHeadMarkup, isCsrIsland, isHydrateOnLoad, isHydrateVisible, kebabCaseToModuleSpecifier, shortestTtl, } from '@lwrjs/shared-utils';
import { SSR_PROPS_ATTR, getPropsId, mergeWarnings } from '../utils.js';
import { getRenderer } from '../renderer.js';
/**
 * This is a view transformer run by the view registry during linking of a page document/route (configured in lwr.config.json[routes]).
 * If the "ssr" bootstrap flag is on for the route, it will server-side render (SSR) each eligible custom element found in the page HTML.
 *
 * Flow:
 *  1. There is a request to generate a view (ie: page document) via the UI middleware or static site generation
 *  2. During view generation, the view registry runs all the registered view transformers (including this one)
 *  3. This view transformer links the SSRed string for EVERY eligible custom element (ie: root component) found in the page document:
 *      a) It requests a module which SSRs a given custom element, generated by "lwc-ssr/moduleProvider"
 *      b) A bundle is created for the generated server bootstrap module (see "./ssr-bootstrap")
 *      c) The bundle code is run inside a worker (see "./ssr-bootstrap"), with context stored in "workerData"
 *      d) RootComponent.getServerData() is run to preload data and <head> markup, if available
 *      e) The generated server bootstrap module (running the worker) passes the SSRed code string, data and cache info back to the main thread
 *      f) The SSRed string is used to overwrite/link each custom element (eg: "<c-app></c-app>") in the document (see "stringBuilder.overwrite")
 *      g) A script containing all the serialized properties is added for hydration
 * 4. The view/page document now contains SSRed components and data, which will be sent to the client
 * 5. During bootstrap on the client, the "lwr/init" module will hydrate the custom elements on the page, as needed
 */
export default function lwcSsrViewTransformer(options, { config, moduleBundler, resourceRegistry }) {
    const routes = [...config.routes, ...config.errorRoutes];
    return {
        name: 'ssr-lwc-transformer',
        async link(stringBuilder, viewContext, metadata) {
            if (!viewContext.view.bootstrap?.ssr) {
                return {}; // no SSR
            }
            logger.debug({ label: 'lwcSsrViewTransformer', message: 'link' });
            logger.verbose({
                label: 'lwcSsrViewTransformer',
                message: 'link input',
                additionalInfo: stringBuilder,
            });
            if (!metadata.serverData) {
                metadata.serverData = {};
            }
            const allBundles = new Set([...(metadata.serverBundles ?? [])]); // make a copy
            const { customElements, serverData } = metadata;
            // Gather all the SSRable custom elements (ie: root components) into 1 list
            const ssrModules = getComponentsToSSR(customElements, stringBuilder);
            const rootSpecifiers = Object.values(ssrModules).map((m) => m.specifier);
            if (!rootSpecifiers.length) {
                return {}; // no SSR because there are no root eligible components
            }
            // SSR and gather the properties and <head> markup for each eligible custom element
            const islands = rootSpecifiers.join(',');
            let pageTtl;
            await getTracer().trace({ name: ViewSpan.RenderIsland, attributes: { specifiers: islands } }, async () => {
                try {
                    const route = routes.find((r) => r.id === viewContext.view.id);
                    if (!route) {
                        throw new Error(`Unable to resolve configuration for view: ${viewContext.view.id}`);
                    }
                    const { results, warnings, bundles: islandBundles, } = await getRenderer(config, moduleBundler, resourceRegistry).render(ssrModules, route, viewContext.runtimeEnvironment, viewContext.runtimeParams, metadata.serverData, false);
                    for (const root in results) {
                        const { html, props, cache } = results[root] || {};
                        const { tagName, startOffset, endOffset, hydrate } = ssrModules[root];
                        pageTtl = shortestTtl(cache?.ttl, pageTtl);
                        if (html) {
                            // Add the props id to the HTML for the custom element
                            // eg: <some-cmp> -> <some-cmp data-lwr-props-id="1234">
                            // Then overwrite the custom element with the SSRed component string
                            let propsAttr = '';
                            if (hydrate) {
                                // Only serialize props for custom elements that are to be hydrated
                                const propsId = getPropsId();
                                const hydrateAttr = props && props[HYDRATE_DIRECTIVE]
                                    ? ` ${HYDRATE_DIRECTIVE}="${props[HYDRATE_DIRECTIVE]}"`
                                    : '';
                                propsAttr = ` ${SSR_PROPS_ATTR}="${propsId}"${hydrateAttr}`;
                                serverData[propsId] = props;
                            }
                            const [, remain] = html.split(`<${tagName}`);
                            stringBuilder.overwrite(startOffset, endOffset, [`<${tagName}`, propsAttr, remain].join(''));
                        }
                    }
                    mergeWarnings(metadata, warnings);
                    metadata.serverBundles = islandBundles
                        ? new Set([...allBundles, ...islandBundles])
                        : allBundles;
                    results &&
                        addHeadMarkup(Object.values(results).map((r) => r.markup), stringBuilder);
                }
                catch (e) {
                    if (e instanceof LwrError)
                        throw e;
                    throw new LwrApplicationError(descriptions.APPLICATION.SSR_ERROR(islands, stringifyError(e)));
                }
            });
            logger.verbose({
                label: 'lwcSsrViewTransformer',
                message: 'response',
                additionalInfo: stringBuilder,
            });
            return { cache: { ttl: pageTtl } };
        },
    };
}
function getComponentsToSSR(customElements, stringBuilder) {
    const cmpInfo = {};
    for (const { tagName, location, props: rawProps = {} } of customElements.values()) {
        const isCsr = isCsrIsland(rawProps);
        if (isCsr && location) {
            // Strip the CSR-only island directive from the HTML
            const { startOffset, endOffset } = location;
            stringBuilder.overwrite(startOffset, endOffset, `<${tagName}></${tagName}>`);
        }
        if (!isCsr && !rawProps?.['lwc:external'] && location) {
            // Only SSR the custom elements which are NOT CSR islands or lwc:external
            const { startOffset, endOffset } = location;
            const specifier = kebabCaseToModuleSpecifier(tagName);
            const isHydrateOnVisible = isHydrateVisible(rawProps);
            const hydrate = isHydrateOnLoad(rawProps) || isHydrateOnVisible;
            const props = { ...rawProps };
            // We need to keep the directive for islands that will be hydrated when visibile
            if (!isHydrateOnVisible) {
                delete props[HYDRATE_DIRECTIVE];
            }
            cmpInfo[specifier] = { startOffset, endOffset, props, tagName, specifier, hydrate };
        }
    }
    return cmpInfo;
}
//# sourceMappingURL=index.js.map