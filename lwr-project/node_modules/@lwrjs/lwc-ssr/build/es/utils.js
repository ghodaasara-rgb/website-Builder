import { buildEnvironmentContext, getFeatureFlags, normalizeVersionToUri, isLambdaEnv, getSpecifier, } from '@lwrjs/shared-utils';
const DEFAULT_SSR_TIMEOUT = 5000; // 5 seconds, override with process.env.SSR_TIMEOUT
export const SSR_PROPS_ATTR = 'data-lwr-props-id';
export function getPropsId() {
    return `lwcprops${Math.floor(Math.random() * 0x10000).toString(16)}`;
}
export function getRenderTimeout() {
    const override = process.env.SSR_TIMEOUT;
    return override ? Number.parseInt(override) : DEFAULT_SSR_TIMEOUT;
}
export async function getLoaderShim(resourceRegistry, runtimeEnvironment, bootstrapConfig) {
    const { debug } = runtimeEnvironment;
    // debug resources are not available in deployed lambda env
    const useDebug = debug && !isLambdaEnv();
    const specifier = getFeatureFlags().LEGACY_LOADER
        ? useDebug
            ? 'lwr-loader-shim-legacy.bundle.js'
            : 'lwr-loader-shim-legacy.bundle.min.js'
        : useDebug
            ? 'lwr-loader-shim.bundle.js'
            : 'lwr-loader-shim.bundle.min.js';
    const resource = await resourceRegistry.getResource({ specifier, version: bootstrapConfig.lwrVersion }, runtimeEnvironment, 
    // HACK: this code is tricky because resource IDs are different between prod vs debug ("lwr-loader-shim.bundle.min.js" vs "lwr-loader-shim.bundle.js").
    // 1. In debug mode on Lambda (during SSR), we need to ignore runtimeEnvironment.debug because we will always ask for the prod version (lwr-loader-shim.bundle.min.js)
    // 2. But when we generate the view, we can't ignore runtimeEnvironment.debug because we need the debug version of the loader shim (lwr-loader-shim.bundle.js)
    { ignoreDebug: !useDebug });
    if (!resource?.content && !resource?.stream) {
        throw new Error('Failed to find the loader shim');
    }
    let result = '';
    if (resource.content) {
        result = resource.content;
    }
    else {
        const stream = resource.stream();
        for await (const chunk of stream) {
            result += chunk;
        }
    }
    result += `\n//# sourceURL=${resource.entry}`;
    return result;
}
export function getLoaderId(config, bootstrapConfig) {
    // TODO W-15509657 - hack: checking `requiredModules` because the loader may not be the same version as the current runtime
    if (config.requiredModules) {
        const id = config.requiredModules.find((specifier) => specifier.startsWith('lwr/loader'));
        if (id) {
            return id;
        }
    }
    // default to the active LWR version
    const version = normalizeVersionToUri(bootstrapConfig.lwrVersion);
    return getFeatureFlags().LEGACY_LOADER ? `lwr/loaderLegacy/v/${version}` : `lwr/loader/v/${version}`;
}
export function getLoaderConfig(bootstrapModule, config, runtimeParams, serverData) {
    return Object.assign({}, {
        bootstrapModule,
        serverData,
        autoBoot: false,
        disableInitDefer: true,
        rootComponents: [],
        endpoints: {
            uris: {
                mapping: `/1/mapping/amd/1/l/${runtimeParams.locale ?? config.i18n.defaultLocale}/mp/`,
            },
        },
        env: {
            ...buildEnvironmentContext(runtimeParams),
            SSR: true,
        },
    }, getFeatureFlags().LEGACY_LOADER
        ? {
            baseUrl: 'ssr',
        }
        : {
            baseUrl: '/',
            imports: {
                'any/thing.js': ['any/thing'],
            },
        });
}
export function getServerBootstrapServices(route) {
    return route.bootstrap.services.reduce((acc, service) => {
        if (service.ssr === true) {
            const serviceId = getSpecifier({ specifier: service.name, version: service.version });
            acc.push(serviceId);
        }
        return acc;
    }, []);
}
export function mergeWarnings(metadata, warnings = []) {
    if (!warnings.length)
        return;
    if (!metadata.serverDebug) {
        metadata.serverDebug = {};
    }
    metadata.serverDebug.warnings = metadata.serverDebug.warnings || [];
    metadata.serverDebug.warnings.push(...warnings);
}
/**
 * Handles request resolution for relative URLs
 */
export function getFinalRequest(request, origin) {
    let finalRequest;
    let finalUrl;
    if (request instanceof Request) {
        const curUrl = request.url;
        // proxy relative URLs through the origin
        if (curUrl.startsWith('/')) {
            finalUrl = origin + curUrl;
            finalRequest = new Request(finalUrl, request);
        }
        else {
            finalUrl = curUrl;
            finalRequest = request;
        }
    }
    else {
        const curUrl = typeof request === 'string' ? request : request.toString(); // handle string-able types, eg: URL
        finalRequest = finalUrl = curUrl.startsWith('/') ? origin + curUrl : curUrl; // proxy relative URLs through the origin
    }
    return { finalRequest, finalUrl };
}
//# sourceMappingURL=utils.js.map