import { Pool as ClientPool } from 'undici';
import { toHostname } from '@lwrjs/shared-utils';
import { getFinalRequest } from './utils.js';
// a single Lambda only services 1 org, so this cache will not grow too large
const CORE_CLIENTS = new Map();
export const ROUTE_CORE_HEADER = 'x-sfdc-route-core'; // helps route requests to Core efficiently, value: true
/**
 * Direct-to-Core: Fetches data with a specialized agent for core requests
 */
export async function fetchWithAgent(request, init, forwardedOrigin, coreProxy, span) {
    let { origin, servername } = coreProxy;
    const { finalUrl } = getFinalRequest(request, origin.startsWith('http') ? origin : forwardedOrigin);
    const forwardedHostname = toHostname(forwardedOrigin);
    const hostHeader = coreProxy.host ?? forwardedHostname;
    const ENHANCED_DOMAIN_TLD = '.site.com';
    const MY_DOMAIN_TLD = '.salesforce.com';
    if (forwardedHostname.endsWith(ENHANCED_DOMAIN_TLD)) {
        const myHostname = forwardedHostname.slice(0, -ENHANCED_DOMAIN_TLD.length) + MY_DOMAIN_TLD;
        // use the Salesforce TLD by replacing the Site TLD
        // caller must be an Enhanced Domain on Cloudflare
        origin = 'https://' + myHostname;
        // do not use SNI with the Enhanced Domain route
        // never include a protocol in the servername
        servername = myHostname;
    }
    else if (origin.startsWith('.')) {
        // use the CDN origin if the leading '.' is missing in the coreProxy origin
        origin = 'https://' + forwardedHostname + origin;
    }
    const urlParts = new URL(finalUrl);
    const path = urlParts.pathname + urlParts.search;
    const url = origin + path;
    const proxyStr = coreProxy ? JSON.stringify(coreProxy) : 'none';
    // The host header and servername attrs are only used for Direct-to-Core requests
    // They are not used again if this request fails and falls back to CDN
    span.setAttributes({
        fetchType: 'direct',
        url,
        coreProxy: proxyStr,
        coreUrl: url,
        coreHostHeader: hostHeader,
        coreServername: servername,
    });
    let client = CORE_CLIENTS.get(origin);
    if (!client) {
        client = new ClientPool(origin, {
            connections: parseInt(process.env.CLIENT_CONNECTION_LIMIT ?? '100', 10),
            keepAliveTimeout: 30000,
        });
        CORE_CLIENTS.set(origin, client);
    }
    return client
        .request({
        ...init,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore - HttpMethod not available for typecasting :|
        method: init.method || 'GET',
        path,
        headers: { ...init?.headers, Host: hostHeader },
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore - not properly typed >:|
        servername,
    })
        .then(async (res) => {
        // Set the core* attrs early, so the info is not lost if we fallback to CDN
        // With no CDN fallback url=coreUrl and statusCode=coreStatusCode
        span.setAttributes({ coreStatusCode: res.statusCode });
        // convert the response to a fetch Response object
        // downstream consumers expect a Response since it's the standard fetch return object
        // this allows callers to check the response with "instanceof Response"
        const bodyBuffer = await res.body.arrayBuffer();
        const body = res.statusCode === 204 || res.statusCode === 205 ? null : bodyBuffer;
        const headers = new Headers();
        for (const [key, value] of Object.entries(res.headers)) {
            if (!value)
                continue;
            const values = Array.isArray(value) ? value : [value];
            values.forEach((v) => headers.append(key, v));
        }
        return new Response(body, { status: res.statusCode, headers });
    });
}
//# sourceMappingURL=directFetch.js.map