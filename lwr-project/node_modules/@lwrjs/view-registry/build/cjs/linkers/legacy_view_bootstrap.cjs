var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};
var __exportStar = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __exportStar(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};

// packages/@lwrjs/view-registry/src/linkers/legacy_view_bootstrap.ts
__markAsModule(exports);
__export(exports, {
  getHtmlResources: () => getHtmlResources
});
var import_diagnostics = __toModule(require("@lwrjs/diagnostics"));
var import_shared_utils = __toModule(require("@lwrjs/shared-utils"));
var import_identity = __toModule(require("@lwrjs/app-service/identity"));
var import_utils = __toModule(require("../utils.cjs"));
var import_utils2 = __toModule(require("./utils.cjs"));
var import_preload_utils = __toModule(require("./preload-utils.cjs"));
var import_lru_cache = __toModule(require("lru-cache"));
function includeIdFactory(bundleConfig) {
  return (moduleRef) => {
    if ((0, import_shared_utils.isExternalSpecifier)(moduleRef.specifier, bundleConfig)) {
      return false;
    }
    return true;
  };
}
var moduleGraphsCache = new import_lru_cache.LRUCache({
  max: parseInt(process.env.MODULE_GRAPH_CACHE_SIZE ?? "500", 10),
  dispose: (_value, key) => {
    if ((0, import_shared_utils.isLambdaEnv)()) {
      import_diagnostics.logger.warn(`Module graph evicted from cache ${key}`);
    } else {
      import_diagnostics.logger.verbose(`Module graph evicted from cache ${key}`);
    }
  }
});
var isRunningLocalDev = (0, import_shared_utils.isLocalDev)();
async function getHtmlResources(view, viewParams, resourceContext) {
  const {
    runtimeEnvironment,
    runtimeParams,
    moduleRegistry,
    moduleBundler,
    resourceRegistry,
    viewMetadata
  } = resourceContext;
  const {format, hmrEnabled, bundle, debug, minify} = runtimeEnvironment;
  const {customElements, serverData, serverDebug} = viewMetadata;
  const isAMD = format === "amd";
  const {bundleConfig, unsafeEnableViewLinkCaching} = resourceContext;
  const {external = {}, exclude = []} = bundleConfig;
  const groups = isAMD ? bundleConfig.groups || {} : {};
  const enableModuleGraphsCache = unsafeEnableViewLinkCaching && !isRunningLocalDev && !process.env.NOCACHE;
  const getPreloadUri = function(rawSpecifier, uriMap) {
    const {specifier} = (0, import_shared_utils.explodeSpecifier)(rawSpecifier);
    if (Object.keys(external).some((e) => specifier === e))
      return;
    const preloadUri = uriMap[rawSpecifier];
    if (!preloadUri && (exclude.includes(specifier) || (0, import_shared_utils.isGroupie)(specifier, groups))) {
      import_diagnostics.logger.warn({
        label: "view-registry",
        message: `Skipping preload of unknown static import: ${rawSpecifier}`
      });
      return;
    }
    return preloadUri;
  };
  const {
    id: appName,
    bootstrap: {services, module: bootstrapModule, preloadModules = []} = {
      services: [],
      preloadModules: []
    }
  } = view;
  const defRegistry = bundle ? moduleBundler : moduleRegistry;
  const depth = isAMD ? {static: import_shared_utils.GraphDepth.ALL, dynamic: (0, import_shared_utils.isMrtBundle)() ? 50 : 1} : {static: import_shared_utils.GraphDepth.NONE, dynamic: 0};
  if (isAMD) {
    depth.includeId = includeIdFactory(bundleConfig);
  }
  const appIdentity = {
    appName,
    format: runtimeEnvironment.format,
    resourceType: import_identity.AppResourceEnum.MODULE
  };
  const bootstrapSpecifier = bootstrapModule || (0, import_identity.getAppSpecifier)(appIdentity);
  const moduleResources = [];
  const requiredResources = [];
  const configResources = [];
  const visitedCache = new Map();
  const imports = {};
  const rootComponents = [];
  const requiredAmdModules = [];
  const viewPreloads = {
    uris: [],
    specifiers: [],
    includedModules: [],
    groups: new Map(),
    integrities: new Map()
  };
  const isSSR = view.bootstrap?.ssr;
  const version = view.bootstrap?.lwrVersion;
  const nonce = (0, import_utils.getViewNonce)(viewParams);
  let bootstrapModuleRef, versionedSpecifier = bootstrapSpecifier;
  const customElementsRecords = [];
  const flattenedElements = (0, import_utils2.flattenCustomElements)(customElements, isSSR);
  const viewContainsLiveElements = !isSSR || flattenedElements.some(({props}) => (0, import_shared_utils.getHydrateDirective)(props));
  if (viewContainsLiveElements) {
    if (isAMD) {
      const shimBundle = debug || minify === false ? "lwr-loader-shim-legacy.bundle.js" : "lwr-loader-shim-legacy.bundle.min.js";
      let def = await resourceRegistry.getResource({specifier: shimBundle, version}, runtimeEnvironment, runtimeParams);
      if (!def) {
        let fallbackShimBundle;
        if (shimBundle === "lwr-loader-shim-legacy.bundle.js") {
          fallbackShimBundle = "lwr-loader-shim-legacy.bundle.min.js";
          def = await resourceRegistry.getResource({specifier: fallbackShimBundle, version}, runtimeEnvironment, runtimeParams);
        } else {
          fallbackShimBundle = "lwr-loader-shim-legacy.bundle.js";
          def = await resourceRegistry.getResource({specifier: fallbackShimBundle, version}, runtimeEnvironment, runtimeParams);
        }
        if (!def) {
          throw Error("Failed to find definition of resource: " + shimBundle);
        }
      }
      if (!def.inline && !def.src) {
        throw Error(`Invalid Shim ${shimBundle}: ${JSON.stringify(def)}`);
      }
      (0, import_utils.addExternalScriptNonce)(def, nonce);
      requiredResources.push(def);
      const errorShimDef = await resourceRegistry.getResource({specifier: "lwr-error-shim.js", version}, runtimeEnvironment, {...runtimeParams, ignoreDebug: true});
      if (!errorShimDef) {
        throw Error("Failed to find definition of resource: lwr-error-shim.js");
      }
      if (!errorShimDef.inline && !errorShimDef.src) {
        throw Error(`Invalid Shim lwr-error-shim.js: ${JSON.stringify(errorShimDef)}`);
      }
      (0, import_utils.addExternalScriptNonce)(errorShimDef, nonce);
      requiredResources.push(errorShimDef);
    }
    let bootstrapModuleGraph;
    const bootstrapModuleGraphCacheKey = (0, import_utils.getModuleGraphCacheKey)(bootstrapSpecifier, runtimeEnvironment, runtimeParams);
    if (enableModuleGraphsCache && moduleGraphsCache.has(bootstrapModuleGraphCacheKey)) {
      bootstrapModuleGraph = moduleGraphsCache.get(bootstrapModuleGraphCacheKey);
    } else {
      import_diagnostics.logger.info({
        label: "view-registry",
        message: `Cache miss for ServerGenerate, cache key: ${bootstrapModuleGraphCacheKey}`
      });
      bootstrapModuleGraph = await (0, import_shared_utils.getModuleGraphs)(bootstrapSpecifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams, visitedCache);
      enableModuleGraphsCache && moduleGraphsCache.set(bootstrapModuleGraphCacheKey, bootstrapModuleGraph);
    }
    bootstrapModuleRef = {
      specifier: bootstrapModuleGraph.graphs[0].specifier,
      flatGraph: bootstrapModuleGraph,
      resources: configResources
    };
    versionedSpecifier = bootstrapModuleGraph.graphs[0].specifier;
    const bootstrapUri = bootstrapModuleGraph.uriMap[versionedSpecifier];
    if (!bootstrapUri) {
      throw Error(`Invalid Module Resource ${versionedSpecifier}`);
    }
    const bootstrapBundleDef = (0, import_utils2.getBundleDefinition)(bootstrapModuleGraph, versionedSpecifier);
    const bootstrapIntegrity = bootstrapBundleDef?.integrity;
    moduleResources.push((0, import_utils.getModuleResourceByUri)(bootstrapUri, runtimeEnvironment, {
      integrity: bootstrapIntegrity,
      isPreload: false,
      isSSR,
      nonce
    }));
    for (const depSpecifier of bootstrapModuleGraph.graphs[0].static) {
      const bootstrapDepUri = getPreloadUri(depSpecifier, bootstrapModuleGraph.uriMap);
      if (bootstrapDepUri) {
        const bootstrapDepIntegrity = (0, import_utils2.getBundleIntegrity)(bootstrapModuleGraph, depSpecifier);
        const bootstrapDepDef = bootstrapModuleGraph.linkedDefinitions[depSpecifier];
        (0, import_preload_utils.setPreloadModulesMeta)(depSpecifier, bootstrapDepUri, bootstrapDepIntegrity, groups, viewPreloads, bootstrapDepDef?.bundleRecord?.includedModules);
      }
    }
    if ((0, import_shared_utils.isBundler)(defRegistry)) {
      for (const specifier of preloadModules) {
        await (0, import_preload_utils.getPreloadModulesMeta)(specifier, viewPreloads, bundleConfig, moduleRegistry, defRegistry, runtimeEnvironment, runtimeParams);
      }
    }
    if (isAMD) {
      requiredAmdModules.push(versionedSpecifier);
      imports[versionedSpecifier] = bootstrapUri;
      addIncludedModulesToImports(bootstrapBundleDef, imports, bootstrapUri);
      const levels = (0, import_shared_utils.isMrtBundle)() ? bootstrapModuleGraph.graphs.length : 1;
      for (let i = 0; i < levels; i++) {
        for (const staticDep of bootstrapModuleGraph.graphs[i].static) {
          const staticDepUri = bootstrapModuleGraph.uriMap[staticDep];
          const staticBundleDef = (0, import_utils2.getBundleDefinition)(bootstrapModuleGraph, staticDep);
          imports[staticDep] = staticDepUri;
          addIncludedModulesToImports(staticBundleDef, imports, staticDepUri);
          if (services?.length && i === 0) {
            requiredAmdModules.push(staticDep);
          }
        }
        for (const dynamicDep of bootstrapModuleGraph.graphs[i].dynamicRefs) {
          const dynamicDepUri = bootstrapModuleGraph.uriMap[dynamicDep];
          if (dynamicDepUri) {
            const dynamicBundleDef = (0, import_utils2.getBundleDefinition)(bootstrapModuleGraph, dynamicDep);
            imports[dynamicDep] = dynamicDepUri;
            addIncludedModulesToImports(dynamicBundleDef, imports, dynamicDepUri);
          } else {
            import_diagnostics.logger.warn({
              label: `view-registry`,
              message: `Skipping unknown dynamic import: ${dynamicDep}`
            });
          }
        }
      }
    }
  }
  await Promise.all(flattenedElements.map(async ({tagName: element, props}) => {
    const hydrateDirective = (0, import_shared_utils.getHydrateDirective)(props);
    const isSsrOnly = isSSR && !hydrateDirective;
    const elementSpecifier = (0, import_shared_utils.kebabCaseToModuleSpecifier)(element);
    const moduleGraphCacheKey = (0, import_utils.getModuleGraphCacheKey)(elementSpecifier, runtimeEnvironment, {
      ...runtimeParams,
      ssr: isSsrOnly
    });
    let graph;
    if (enableModuleGraphsCache && moduleGraphsCache.has(moduleGraphCacheKey)) {
      graph = moduleGraphsCache.get(moduleGraphCacheKey);
    } else {
      graph = await (0, import_shared_utils.getModuleGraphs)(elementSpecifier, {includeUris: true, includeLinkedDefinitions: true, depth}, moduleRegistry, defRegistry, runtimeEnvironment, {...runtimeParams, ssr: isSsrOnly}, visitedCache);
      enableModuleGraphsCache && moduleGraphsCache.set(moduleGraphCacheKey, graph);
    }
    customElementsRecords.push({elementName: element, flatGraph: graph});
    if (!isSSR || (0, import_shared_utils.getHydrateDirective)(props)) {
      const specifier = graph.graphs[0].specifier;
      const elementUri = graph.uriMap[specifier];
      const elementIntegrity = (0, import_utils2.getBundleIntegrity)(graph, specifier);
      const elementBundleDef = graph.linkedDefinitions[specifier];
      const includedModules = elementBundleDef?.bundleRecord ? elementBundleDef.bundleRecord.includedModules : [];
      (0, import_preload_utils.setPreloadModulesMeta)(specifier, elementUri, elementIntegrity, groups, viewPreloads, includedModules);
      if (bundle) {
        for (const depSpecifier of graph.graphs[0].static) {
          const elementDepUri = getPreloadUri(depSpecifier, graph.uriMap);
          if (elementDepUri) {
            const elementDepIntegrity = (0, import_utils2.getBundleIntegrity)(graph, depSpecifier);
            const elementDepDef = graph.linkedDefinitions[depSpecifier];
            (0, import_preload_utils.setPreloadModulesMeta)(depSpecifier, elementDepUri, elementDepIntegrity, groups, viewPreloads, elementDepDef?.bundleRecord?.includedModules);
          }
        }
      }
      rootComponents.push(specifier);
      imports[specifier] = elementUri;
      addIncludedModulesToImports(elementBundleDef, imports, elementUri);
      if (isAMD) {
        const levels = (0, import_shared_utils.isMrtBundle)() ? graph.graphs.length : 1;
        for (let i = 0; i < levels; i++) {
          for (const staticDep of graph.graphs[i].static) {
            const elementStaticDepUri = graph.uriMap[staticDep];
            const elementStaticBundleDef = (0, import_utils2.getBundleDefinition)(graph, staticDep);
            imports[staticDep] = elementStaticDepUri;
            addIncludedModulesToImports(elementStaticBundleDef, imports, elementStaticDepUri);
          }
          for (const dynamicDep of graph.graphs[i].dynamicRefs) {
            const elementDynamicDepUri = graph.uriMap[dynamicDep];
            const elementDynamicBundleDef = (0, import_utils2.getBundleDefinition)(graph, dynamicDep);
            imports[dynamicDep] = elementDynamicDepUri;
            addIncludedModulesToImports(elementDynamicBundleDef, imports, elementDynamicDepUri);
          }
        }
      }
    }
  }));
  if (viewContainsLiveElements || serverDebug?.warnings?.length) {
    if ((0, import_shared_utils.isLocalDev)()) {
      const localDevSpecifier = "lwr_local_dev/bootstrap";
      rootComponents.push(localDevSpecifier);
      const localDevMod = await (0, import_utils.getModuleResource)({specifier: localDevSpecifier, version: ""}, runtimeEnvironment, {}, moduleRegistry, runtimeParams);
      if (localDevMod.src)
        imports[localDevSpecifier] = localDevMod.src;
    }
    configResources.unshift((0, import_utils2.getViewBootstrapConfigurationResource)({
      id: view.id,
      url: viewParams?.page?.url,
      configAsSrc: view.bootstrap?.configAsSrc || false,
      mixedMode: view.bootstrap?.mixedMode || false,
      nonce: viewParams?.page?.nonce,
      ssr: view.bootstrap?.ssr || false
    }, {
      appId: appIdentity.appName,
      bootstrapModule: versionedSpecifier,
      autoBoot: view.bootstrap?.autoBoot === false ? false : true,
      importMappings: {
        imports,
        default: (0, import_shared_utils.getModuleUriPrefix)(runtimeEnvironment, runtimeParams)
      },
      rootComponents,
      serverData,
      ...isAMD && {requiredModules: requiredAmdModules},
      ...isAMD && {preloadModules: (0, import_preload_utils.getPreloadModuleList)(viewPreloads)}
    }, runtimeEnvironment, runtimeParams, serverDebug?.warnings));
  }
  if (!isAMD && hmrEnabled) {
    configResources.unshift((0, import_utils2.getViewHmrConfigurationResource)(view, viewMetadata));
  }
  const dedupedUris = [...new Set(viewPreloads.uris)];
  for (const preloadUri of dedupedUris) {
    const preloadIntegrity = viewPreloads.integrities.get(preloadUri);
    moduleResources.push((0, import_utils.getModuleResourceByUri)(preloadUri, runtimeEnvironment, {
      integrity: preloadIntegrity,
      isPreload: true,
      isSSR,
      nonce
    }));
  }
  const htmlResources = await Promise.all([...configResources, ...requiredResources, ...moduleResources].map(import_utils.generateHtmlTag));
  return {
    partial: htmlResources.join("\n"),
    viewRecord: {
      resources: requiredResources,
      customElements: customElementsRecords,
      moduleResources,
      bootstrapModule: bootstrapModuleRef
    }
  };
}
function addIncludedModulesToImports(bundleDef, imports, uri) {
  if ((0, import_shared_utils.isMrtBundle)()) {
    bundleDef?.bundleRecord?.includedModules?.forEach((module2) => {
      if (!imports[module2]) {
        imports[module2] = uri;
      }
    });
  }
}
