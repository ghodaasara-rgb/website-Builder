import path from 'path';
import { spawn } from 'child_process';
import chalk from 'chalk';
import express from 'express';
import fs from 'fs-extra';
import { DEFAULT_PROXY_PORT, findProxyConfiguration } from '@lwrjs/dev-proxy-server';
import { logger } from '@lwrjs/diagnostics';
import { isLocalAuthEnabled, launch } from '@lwrjs/shared-utils';
import { getDefaultBuildDirectory, setupProxy } from './utils.js';
import { injectLocalDevHacks } from './setup-dev.js';
// TODO need to refactor start from preview & other experience commands
export async function expPreview(options) {
    const { rootDir, config, port, target, mode, buildDir, basePath, open, logLevel, timeout } = options;
    try {
        process.env.LWR_LOG_LEVEL = logLevel; // Set the log level
        if (timeout) {
            process.env.SSR_TIMEOUT = `${timeout}`;
        }
        if (options.authToken) {
            process.env.AUTH_TOKEN = options.authToken;
            process.env.MRT_ALLOW_COOKIES = 'true';
        }
        // if PROXY_FOR_SSR is not manually set, disable direct-to-core routing during local preview
        if (process.env.PROXY_FOR_SSR === undefined)
            process.env.PROXY_FOR_SSR = 'false';
        // adding some context to know if we are running in local preview mode
        process.env.LOCAL_PREVIEW_MODE = 'true';
        const serverMode = mode;
        // runtimePort can be undefined on invocation. The actual value is resolved via createServer()
        let runtimePort = target === 'mrt' && !port ? 3000 : port;
        const proxyPort = port === undefined ? DEFAULT_PROXY_PORT : port;
        // Use provided basePath or get from app config as fallback
        let appBasePath = basePath;
        // if you specified a buildDir in CLI and it doesn't exist, throw an error
        if (buildDir && !fs.existsSync(buildDir)) {
            throw new Error(`specified build directory '${buildDir}' does not exist`);
        }
        // Get the proper build directory
        const dir = buildDir ? buildDir : getDefaultBuildDirectory(rootDir, config, target);
        const proxyConfig = findProxyConfiguration(rootDir, dir);
        if (proxyConfig) {
            runtimePort = proxyPort + 1;
            const remoteOrigin = proxyConfig.proxyConfigs.length ? proxyConfig.proxyConfigs[0][1] : undefined;
            await setupProxy(runtimePort, proxyPort, appBasePath || '', {
                ...proxyConfig,
                remoteOrigin,
            });
        }
        if (target === 'mrt') {
            process.env.MRT_PREVIEW = 'true';
            const ssrJs = path.join(dir, 'ssr.js');
            // TODO HACKS FOR AUTHENTICATION
            // This overrides the __Secure_has_id cookie when running a site locally
            // This is needed because chrome will not allow secure cookies to be set in a non-secure context (http)
            if (isLocalAuthEnabled()) {
                injectLocalDevHacks(path.join(dir, 'experience', 'index_csr.html'));
                injectLocalDevHacks(path.join(dir, 'experience', 'index.html'));
            }
            // If ssr.js exists, run it
            if (fs.existsSync(ssrJs)) {
                // TODO: Add IPC to notify when server is started.
                spawn('node', [`${ssrJs}`], {
                    cwd: process.cwd(),
                    env: {
                        ...process.env,
                        PORT: runtimePort.toString(),
                        // The `open` option is not used when target === mrt because `pwa-kit` launches the browser.
                        // The following env var will prevent `pwa-kit` from opening the browser, but we should work with
                        // them on a better api to control this:
                        // `process.env.NODE_ENV = 'test';`
                        NODE_ENV: 'test',
                        NODE_OPTIONS: [process.env.NODE_OPTIONS, options?.debug ? '--inspect-brk' : '']
                            .filter(Boolean)
                            .join(' ')
                            .trim(),
                    },
                    stdio: 'inherit',
                });
            }
            else {
                // If no ssr js, throw an error
                throw new Error(`cannot find ssr.js in build directory '${dir}'`);
            }
        }
        else {
            // Not mrt, just launch LWR server
            const { createServer } = await import('@lwrjs/core');
            const server = createServer({
                port: runtimePort,
                serverMode,
                rootDir,
                lwrConfigFile: config,
            });
            const internalServer = server.getInternalServer();
            // Get the app config from the server to check for basePath
            let appConfig;
            try {
                appConfig = server.getConfig();
                // Use provided basePath or fallback to app config
                appBasePath = appBasePath || appConfig?.basePath;
            }
            catch (error) {
                // If we can't get the app config, just use the provided basePath
            }
            // TODO we could just run a static server vs running LWR services here
            if (fs.existsSync(dir)) {
                // Use static directory if it exists
                logger.info({
                    label: `cli`,
                    message: `Using prebuilt content from directory: ${dir}`,
                });
                // Update the static middleware logic to use appBasePath:
                if (appBasePath) {
                    try {
                        const normalizedBasePath = appBasePath.startsWith('/')
                            ? appBasePath
                            : `/${appBasePath}`;
                        const basePathDir = path.join(dir, appBasePath.replace(/^\//, ''));
                        logger.info({
                            label: `cli`,
                            message: `Serving static files under basePath: ${normalizedBasePath} from directory: ${basePathDir}`,
                        });
                        // Mount static middleware at root level to handle basePath requests
                        internalServer.use((req, res, next) => {
                            try {
                                // Check if request starts with basePath
                                if (req.originalUrl.startsWith(normalizedBasePath)) {
                                    // Remove basePath from the URL to get the relative path
                                    const relativePath = req.originalUrl.substring(normalizedBasePath.length);
                                    // Decode URL-encoded characters in the path
                                    const decodedPath = decodeURIComponent(relativePath);
                                    const filePath = path.join(basePathDir, decodedPath);
                                    // Check if file exists
                                    if (fs.existsSync(filePath)) {
                                        res.sendFile(path.resolve(filePath));
                                        return;
                                    }
                                }
                                next();
                            }
                            catch (error) {
                                next();
                            }
                        });
                    }
                    catch (error) {
                        internalServer.use(express.static(dir));
                    }
                }
                else {
                    logger.info({
                        label: `cli`,
                        message: `Serving static files from root path, directory: ${dir}`,
                    });
                    internalServer.use(express.static(dir));
                }
            }
            await server.listen(async ({ serverMode, port: appPort }) => {
                runtimePort = appPort;
            });
        }
        const sitePort = proxyConfig !== undefined ? proxyPort : runtimePort;
        let serverUrl = `http://localhost:${sitePort}`;
        if (options.basePath) {
            const normalizedBasePath = options.basePath.startsWith('/')
                ? options.basePath
                : `/${options.basePath}`;
            serverUrl += normalizedBasePath;
        }
        // Site expects a '/' at the end of server url
        serverUrl = serverUrl.endsWith('/') ? serverUrl : `${serverUrl}/`;
        // eslint-disable-next-line no-console
        console.log(chalk.green(`Application is available at: ${serverUrl}`));
        // TODO: Standardize support for the --open option for all server configurations.
        // This opens to quickly for target=mrt configuration.
        if (open && target !== 'mrt') {
            await launch(runtimePort, undefined, options.basePath);
        }
    }
    catch (error) {
        logger.error(error);
        process.exit(1);
    }
}
//# sourceMappingURL=exp-preview.js.map