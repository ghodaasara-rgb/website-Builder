import { SpanStatusCode, context, trace } from '@opentelemetry/api';
import { RandomIdGenerator } from '@opentelemetry/sdk-trace-base';
import { version } from '@lwrjs/instrumentation/package';
import { DefaultSpans } from './spans.js';
import { LWR_TRACE_CONTEXT, getContextKey } from './context.js';
export var TraceLevel;
(function (TraceLevel) {
    TraceLevel["OFF"] = "off";
    TraceLevel["DEFAULT"] = "default";
    TraceLevel["VERBOSE"] = "verbose";
})(TraceLevel || (TraceLevel = {}));
function getTraceLevel() {
    const level = process.env.LWR_TRACING;
    if (!level) {
        return TraceLevel.OFF;
    }
    if (Object.values(TraceLevel).includes(level)) {
        return level;
    }
    return TraceLevel.DEFAULT;
}
function shouldTrace(level, id) {
    return (level === TraceLevel.VERBOSE ||
        (level === TraceLevel.DEFAULT && DefaultSpans.has(id.name)) ||
        (level === TraceLevel.DEFAULT && !id.name.startsWith('lwr.')) // all custom traces
    );
}
function isPromise(promise) {
    return !!promise && typeof promise.then === 'function';
}
function handleError(span, error) {
    if (error) {
        span.recordException(error);
    }
    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message });
    span.end();
}
/**
 *  Tracer - encapsulates open-telemetry tracing apis
 */
class Tracer {
    traceLevel = getTraceLevel();
    startSpan(id, options) {
        if (!shouldTrace(this.traceLevel, id)) {
            return new DisabledSpan();
        }
        return new LwrSpanImpl(id, options);
    }
    trace(id, fn) {
        if (!shouldTrace(this.traceLevel, id)) {
            return fn(new DisabledSpan());
        }
        const api = trace.getTracer('lwr', version);
        const activeContext = context.active();
        return context.with(activeContext.setValue(LWR_TRACE_CONTEXT, getContextKey()), () => {
            return api.startActiveSpan(id.name, (span) => {
                if (id.attributes) {
                    span.setAttributes(id.attributes);
                }
                // Add LWR version to the attributes
                span.setAttribute('lwrVersion', version);
                try {
                    const lwrSpan = {
                        traceId: span.spanContext().traceId,
                        spanId: span.spanContext().spanId,
                        parentSpanId: span.parentSpanId,
                        setAttributes: span.setAttributes.bind(span),
                        end: span.end,
                    };
                    const result = fn(lwrSpan);
                    if (isPromise(result)) {
                        result.then(() => span.end(), (err) => handleError(span, err));
                        return result;
                    }
                    span.end();
                    return result;
                }
                catch (err) {
                    handleError(span, err);
                    throw err;
                }
            });
        });
    }
}
/**
 * LwrSpan - encapsulates open-telemetry span functionality
 */
class LwrSpanImpl {
    span;
    constructor(id, options) {
        const api = trace.getTracer('lwr', version);
        const activeContext = context.active();
        this.span = api.startSpan(id.name, options, activeContext);
        if (id.attributes) {
            this.setAttributes(id.attributes);
        }
    }
    get traceId() {
        return this.span.spanContext().traceId;
    }
    get spanId() {
        return this.span.spanContext().spanId;
    }
    get parentSpanId() {
        return this.span.parentSpanId;
    }
    setAttributes(attributes) {
        this.span.setAttributes(attributes);
        return this;
    }
    end(endTime) {
        this.span.end(endTime);
    }
}
/**
 * Span that generates OpenTelemetry-standard IDs without full tracing overhead.
 * Used when LWR_TRACING=off but we still want proper trace correlation.
 */
class DisabledSpan {
    traceId;
    spanId;
    constructor() {
        // Use OpenTelemetry's official ID generator for maximum compatibility
        // This ensures IDs follow OpenTelemetry specifications exactly
        const idGenerator = new RandomIdGenerator();
        this.traceId = idGenerator.generateTraceId();
        this.spanId = idGenerator.generateSpanId();
    }
    setAttributes(attributes) {
        return this;
    }
    end() {
        return;
    }
}
/**
 * Tracer Singleton
 */
export const getTracer = (() => {
    const tracer = new Tracer();
    return () => tracer;
})();
//# sourceMappingURL=tracer.js.map