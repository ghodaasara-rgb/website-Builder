import { ExportResultCode, hrTimeToMilliseconds, hrTimeToTimeStamp } from '@opentelemetry/core';
import { getFeatureFlags } from '@lwrjs/shared-utils';
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { MetricsSender } from '@salesforce/pwa-kit-runtime/utils/ssr-server/metrics-sender.js';
import { BaseDocRequestSpans, RequestHandlerSpan, ViewSpan } from './spans.js';
const DEFAULT_DIMENSIONS = {
    Project: process.env.MOBIFY_PROPERTY_ID,
    Target: process.env.DEPLOY_TARGET,
};
// only report metrics that are used for graphs
const SUPPORTED_SPANS = new Set([
    RequestHandlerSpan.GetView,
    RequestHandlerSpan.GetAsset,
    ViewSpan.ExecuteRouteHandler,
    ViewSpan.GetServerData,
]);
function toDurationMetric(name, span) {
    return {
        name,
        dimensions: DEFAULT_DIMENSIONS,
        timestamp: new Date(hrTimeToTimeStamp(span.startTime)),
        unit: 'Milliseconds',
        value: hrTimeToMilliseconds(span.duration),
    };
}
function toCountMetric(name, span) {
    return {
        name,
        dimensions: DEFAULT_DIMENSIONS,
        timestamp: new Date(hrTimeToTimeStamp(span.startTime)),
        unit: 'Count',
        value: 1,
    };
}
function getErrorType(span) {
    if (span.status.code > 0 && span.events.length === 0) {
        return;
    }
    for (const event of span.events) {
        if (event.name === 'exception' && event.attributes) {
            if (typeof event.attributes['exception.type'] === 'string') {
                return event.attributes['exception.type'];
            }
        }
    }
}
function isFrameworkError(errorType) {
    return (errorType !== 'DiagnosticsError' &&
        errorType !== 'LwrApplicationError' &&
        errorType !== 'LwrInvalidError' &&
        errorType !== 'LwrStatusError');
}
function toCustomMetrics(span) {
    const metrics = [];
    const errorType = getErrorType(span);
    // view availability metrics
    if (span.name === RequestHandlerSpan.GetView) {
        metrics.push(toDurationMetric('ResolveViewTime', span));
        if (errorType && isFrameworkError(errorType)) {
            metrics.push(toCountMetric('ResolveViewErrors', span));
        }
        else if (errorType) {
            metrics.push(toCountMetric('ResolveViewAppErrors', span));
        }
    }
    // route handler availability metrics
    if (span.name === ViewSpan.ExecuteRouteHandler) {
        metrics.push(toDurationMetric('RouteHandlerTime', span));
        if (errorType && errorType === 'LwrApplicationError') {
            metrics.push(toCountMetric('RouteHandlerErrors', span));
        }
    }
    // asset availability metrics
    if (span.name === RequestHandlerSpan.GetAsset) {
        metrics.push(toDurationMetric('ResolveAssetTime', span));
        if (errorType && isFrameworkError(errorType)) {
            metrics.push(toCountMetric('ResolveAssetErrors', span));
        }
        else if (errorType) {
            metrics.push(toCountMetric('ResolveAssetAppErrors', span));
        }
    }
    // external request availability metrics
    if (span.name === ViewSpan.GetServerData) {
        // reusing pwa-kit metric name for `getServerData` duration
        metrics.push(toDurationMetric('ExternalRequestTime', span));
        if (errorType && isFrameworkError(errorType)) {
            // reusing pwa-kit metric name for `getServerData` errors
            metrics.push(toCountMetric('ExternalRequestFailed', span));
        }
        else if (errorType) {
            // separate app layer `getServerData` errors from framework
            metrics.push(toCountMetric('ExternalAppRequestFailed', span));
        }
        if (getFeatureFlags().DATA_PROVIDER_METRICS) {
            // Extract and publish individual data provider metrics
            const dataProviderMetrics = extractDataProviderMetrics(span);
            metrics.push(...dataProviderMetrics);
        }
    }
    return metrics;
}
function extractDataProviderMetrics(span) {
    const metrics = [];
    const attributes = span.attributes;
    // Extract data provider lists from span attributes
    const dataProviderSuccess = attributes.dataProviderSuccess;
    const dataProviderWarnings = attributes.dataProviderWarnings;
    const dataProviderFailed = attributes.dataProviderFailed;
    const timestamp = new Date(hrTimeToTimeStamp(span.startTime));
    // Create individual DataProviderSuccess metrics
    const successProviders = dataProviderSuccess?.filter((name) => name && name.length > 0);
    successProviders?.forEach((providerName) => {
        metrics.push({
            name: 'DataProviderSuccess',
            dimensions: {
                ...DEFAULT_DIMENSIONS,
                DataProviderName: providerName,
            },
            timestamp,
            unit: 'Count',
            value: 1,
        });
    });
    // Create individual DataProviderFailure metrics for warnings
    const warningProviders = dataProviderWarnings?.filter((name) => name && name.length > 0);
    warningProviders?.forEach((providerName) => {
        metrics.push({
            name: 'DataProviderFailure',
            dimensions: {
                ...DEFAULT_DIMENSIONS,
                DataProviderName: providerName,
            },
            timestamp,
            unit: 'Count',
            value: 1,
        });
    });
    // Create individual DataProviderFailure metrics for errors
    const failedProviders = dataProviderFailed?.filter((name) => name && name.length > 0);
    failedProviders?.forEach((providerName) => {
        metrics.push({
            name: 'DataProviderFailure',
            dimensions: {
                ...DEFAULT_DIMENSIONS,
                DataProviderName: providerName,
            },
            timestamp,
            unit: 'Count',
            value: 1,
        });
    });
    return metrics;
}
export function convertToReadableSpan(span) {
    if (!span) {
        return {};
    }
    return {
        traceId: span.spanContext?.().traceId,
        parentId: span.parentSpanId,
        traceState: span.spanContext?.().traceState?.serialize(),
        name: span.name,
        id: span.spanContext?.().spanId,
        kind: span.kind,
        ...(span.startTime
            ? {
                timestamp: hrTimeToTimeStamp(span.startTime),
            }
            : {}),
        ...(span.duration
            ? {
                duration: hrTimeToMilliseconds(span.duration),
            }
            : {}),
        attributes: span.attributes,
        status: span.status,
        events: span.events,
        links: span.links,
        // OTel span format (traceId -> trace_id, id -> span_id, parentId -> parent_id)
        start_time: span.startTime,
        end_time: span.endTime,
        // tell MRT whether to forward this trace (eg: to MonCloud)
        // must be part of a base doc request because the MRT trace forwarder can only handle one span context
        forwardTrace: process.env.DISABLE_B3_TRACING?.toLowerCase() !== 'true' &&
            process.env.MRT_B3_TRACING?.toLowerCase() !== 'false' &&
            BaseDocRequestSpans.has(span.name),
    };
}
export class AWSExporter {
    metricsSender = MetricsSender.getSender();
    isShutdown = false;
    // Use the env variable directly rather than shared utils to avoid dependencies in this package
    isLambda = process.env.AWS_LAMBDA_FUNCTION_NAME;
    export(spans, done) {
        if (this.isShutdown) {
            done({
                code: ExportResultCode.FAILED,
                error: new Error('Failed to export spans: Exporter shutdown'),
            });
            return;
        }
        // log all spans even if they are not exported as a custom metric
        this.log(spans);
        if (!this.isLambda) {
            done({ code: ExportResultCode.SUCCESS });
            return;
        }
        this.send(spans.filter(({ name }) => SUPPORTED_SPANS.has(name)), done);
    }
    log(spans) {
        for (const span of spans) {
            // eslint-disable-next-line
            console.log(JSON.stringify(convertToReadableSpan(span)));
        }
    }
    send(spans, done) {
        this.metricsSender.send(spans.map(toCustomMetrics).flat());
        done({ code: ExportResultCode.SUCCESS });
    }
    async shutdown() {
        this.isShutdown = true;
    }
}
//# sourceMappingURL=aws-exporter.js.map