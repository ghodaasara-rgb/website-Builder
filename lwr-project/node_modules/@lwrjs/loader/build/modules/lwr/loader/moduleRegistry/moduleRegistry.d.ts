import { ImportMetadataResolver } from './importMetadataResolver.js';
import type { HandleStaleModuleHook, LoaderHooks, ResolveHookResponse } from '@lwrjs/types';
import type { LoaderConfig } from '../../../../types.js';
export type Module = {
    [key: string]: any;
    __useDefault?: boolean;
};
export declare class ModuleRegistry {
    private profiler;
    private warnings;
    private isAppMounted;
    constructor(config: LoaderConfig);
    load(id: string, importer?: string): Promise<Module>;
    resolve(id: string, importer?: string): Promise<string>;
    has(id: string): boolean;
    define(name: string, dependencies: string[], exporter: Function): void;
    /**
     * Marks modules as "externally" loaded/provided, so that the loader does not attempt to fetch them.
     *
     * @param modules - list of module identifiers
     */
    registerExternalModules(modules: string[]): void;
    private resolver;
    private namedDefineRegistry;
    private moduleRegistry;
    aliases: Map<string, string>;
    private lastDefine;
    getImportMetadataResolver(): ImportMetadataResolver;
    /**
     * Gets or creates a module record for the given resolved ID and original ID.
     *
     * This function handles the complex logic of module resolution and ensures that:
     * 1. Modules loaded via different paths (aliases, direct specifiers, URLs) return the same instance
     * 2. Bundle URLs are properly resolved to their final specifier names after instantiation
     * 3. Alias mappings are maintained for future lookups
     *
     * @param resolvedId - The resolved module identifier (could be a URL or specifier)
     * @param originalId - The original module specifer that was requested
     * @returns Promise<ModuleRecord> - The module record for the module
     */
    private getModuleRecord;
    private storeModuleAlias;
    private getModuleDependencyRecord;
    private topLevelEvaluation;
    private evaluateModule;
    private isNamedExportDefaultOnly;
    private getCircularDependencyWrapper;
    private evaluateModuleDependencies;
    private getModuleDef;
    private resolveHook?;
    private loadHook?;
    addLoaderPlugin(hooks: LoaderHooks): void;
    private importMetadataInvalidationCallback;
    private handleStaleModuleHook?;
    registerHandleStaleModuleHook(handleStaleModule: HandleStaleModuleHook): void;
    isValidResolveResponse(res: ResolveHookResponse): boolean;
    getModuleWarnings(isAppMounted?: boolean): Record<string, string[]>;
    logMessage(logType: string, message: string): void;
}
//# sourceMappingURL=moduleRegistry.d.ts.map