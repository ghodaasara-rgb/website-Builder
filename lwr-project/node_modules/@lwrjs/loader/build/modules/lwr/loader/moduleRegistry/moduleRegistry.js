/* global process console */
import { invariant, NO_AMD_REQUIRE, LoaderError, FAIL_INSTANTIATE, FAILED_DEP, UNRESOLVED, INVALID_HOOK, INVALID_LOADER_SERVICE_RESPONSE, MODULE_LOAD_TIMEOUT, EXPORTER_ERROR, } from '../errors/messages.js';
import { resolveIfNotPlainOrUrl, isUrl } from '../utils/url.js';
import { hasDocument, hasConsole, hasProcessEnv } from '../utils/dom.js';
import { loadModuleDef } from './scriptLoad.js';
import { ImportMetadataResolver } from './importMetadataResolver.js';
import { evaluateHandleStaleModuleHooks } from '../hooks/moduleInvalidation.js';
import { evaluateLoadHookResponse, evaluateLoadHook, isResponseAPromise, } from '../hooks/resolveAndLoadHook.js';
import { MODULE_DEFINE, MODULE_ERROR, MODULE_FETCH, MODULE_DYNAMIC_LOAD } from 'lwr/metrics';
import { MODULE_LOAD_TIMEOUT_TIMER, MODULE_WARNING } from '../constants/constants.js';
export class ModuleRegistry {
    constructor(config) {
        this.isAppMounted = false;
        // A registry for named AMD defines containing the *metadata* of AMD module
        this.namedDefineRegistry = new Map();
        // The evaluated module registry where the module identifier (name or URL?) is the key
        this.moduleRegistry = new Map();
        // Aliases of modules in the registry
        this.aliases = new Map();
        this.profiler = config.profiler;
        this.resolver = new ImportMetadataResolver(config, this.importMetadataInvalidationCallback.bind(this));
        this.warnings = {
            [MODULE_WARNING.MODULE_REDEFINE]: [],
            [MODULE_WARNING.MODULE_ALREADY_LOADED]: [],
            [MODULE_WARNING.ALIAS_UPDATE]: [],
        };
    }
    async load(id, importer) {
        const metadata = importer ? { importer } : {};
        this.profiler.logOperationStart({
            id: MODULE_DYNAMIC_LOAD,
            specifier: id,
            metadata,
        });
        const resolvedId = await this.resolve(id, importer);
        const moduleRecord = await this.getModuleRecord(resolvedId, id);
        if (moduleRecord.evaluated) {
            return moduleRecord.module;
        }
        else {
            if (!moduleRecord.evaluationPromise) {
                moduleRecord.evaluationPromise = this.topLevelEvaluation(moduleRecord);
            }
            return moduleRecord.evaluationPromise;
        }
    }
    async resolve(id, importer) {
        const parentUrl = this.resolver.getBaseUrl(); // only support baseUrl for now
        let resolved;
        let aliasedId = id;
        const resolveHooks = this.resolveHook;
        if (resolveHooks) {
            for (let i = 0; i < resolveHooks.length; i++) {
                const resolveHook = resolveHooks[i];
                const response = resolveHook(aliasedId, { parentUrl });
                let result;
                if (response || response === null) {
                    // eslint-disable-next-line no-await-in-loop
                    result = isResponseAPromise(response) ? await response : response;
                }
                if (!this.isValidResolveResponse(result)) {
                    throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                }
                // if result is not null, attempt resolution
                if (result !== null) {
                    if (typeof result === 'string') {
                        if (resolveIfNotPlainOrUrl(result, parentUrl)) {
                            // string response can't be a URL
                            throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                        }
                        aliasedId = result; // the next hook will receive the new id
                        continue;
                    }
                    resolved =
                        result && result.url && (resolveIfNotPlainOrUrl(result.url, parentUrl) || result.url);
                    if (!resolved) {
                        throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                    }
                    // Don't process any more hooks if we have resolved
                    break;
                }
            }
            if (aliasedId !== id) {
                // resolved module id is the aliased module if it has already been defined
                if (!resolved && this.namedDefineRegistry.has(aliasedId)) {
                    return aliasedId;
                }
                else {
                    id = aliasedId;
                }
            }
        }
        if (!resolved) {
            const resolvedOrPlain = resolveIfNotPlainOrUrl(id, parentUrl) || id;
            // if module registry already has named module the resolved id is the plain id
            if (this.moduleRegistry.has(resolvedOrPlain)) {
                return resolvedOrPlain;
            }
            const resolvedUrl = this.resolver.resolveLocal(resolvedOrPlain);
            if (resolvedUrl) {
                // resolve to the bare specifier if conditions are met
                if (this.namedDefineRegistry.has(resolvedOrPlain)) {
                    const namedDefineRecord = this.namedDefineRegistry.get(resolvedOrPlain);
                    if (namedDefineRecord.external || namedDefineRecord.defined) {
                        const record = this.moduleRegistry.get(resolvedUrl);
                        if (!record || !this.aliases.has(resolvedOrPlain)) {
                            return resolvedOrPlain;
                        }
                    }
                }
                return resolvedUrl;
            }
            if (this.namedDefineRegistry.has(resolvedOrPlain)) {
                return resolvedOrPlain;
            }
            try {
                resolved = await this.resolver.resolve(resolvedOrPlain);
            }
            catch (e) {
                // defer to error handling below for unresolved
            }
        }
        if (!resolved || !isUrl(resolved)) {
            if (this.namedDefineRegistry.has(id)) {
                return id;
            }
            throw new LoaderError(UNRESOLVED, [id]);
        }
        if (importer && isUrl(resolved)) {
            resolved += `?importer=${encodeURIComponent(importer)}`;
        }
        return resolved;
    }
    has(id) {
        return this.moduleRegistry.has(id);
    }
    define(name, dependencies, exporter) {
        const mod = this.namedDefineRegistry.get(name);
        // Don't allow redefining a module.
        if (mod && mod.defined) {
            if (
            // note: we always expect process.env.NODE_ENV to be replaced at build time
            // eslint-disable-next-line lwr/no-unguarded-apis
            process.env.NODE_ENV !== 'production' &&
                hasProcessEnv &&
                // eslint-disable-next-line lwr/no-unguarded-apis
                process.env.MRT_HMR !== 'true') {
                if (!this.warnings[MODULE_WARNING.MODULE_REDEFINE].includes(name)) {
                    this.warnings[MODULE_WARNING.MODULE_REDEFINE].push(name);
                }
                if (this.isAppMounted) {
                    this.logMessage('warning', `${MODULE_WARNING.MODULE_REDEFINE}: ${name}`);
                }
            }
            this.lastDefine = mod;
            return;
        }
        const moduleDef = {
            name,
            dependencies,
            exporter,
            defined: true,
        };
        if (mod && mod.external) {
            // if module is "external", resolve the external promise to notify any dependees
            mod.external.resolveExternal(moduleDef);
        }
        this.profiler.logOperationStart({ id: MODULE_DEFINE, specifier: name });
        this.namedDefineRegistry.set(name, moduleDef);
        this.lastDefine = moduleDef;
    }
    /**
     * Marks modules as "externally" loaded/provided, so that the loader does not attempt to fetch them.
     *
     * @param modules - list of module identifiers
     */
    registerExternalModules(modules) {
        modules.map((id) => {
            if (!this.namedDefineRegistry.has(id)) {
                let resolveExternal;
                let timer;
                const moduleDefPromise = new Promise((resolve, reject) => {
                    resolveExternal = resolve;
                    // watch the external for timeout
                    // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                    timer = setTimeout(() => {
                        reject(new LoaderError(MODULE_LOAD_TIMEOUT, [id]));
                    }, MODULE_LOAD_TIMEOUT_TIMER);
                }).finally(() => {
                    // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                    clearTimeout(timer);
                });
                const moduleDef = {
                    name: id,
                    defined: false,
                    external: {
                        resolveExternal,
                        moduleDefPromise,
                    },
                };
                this.namedDefineRegistry.set(id, moduleDef);
                // eslint-disable-next-line lwr/no-unguarded-apis
            }
            else if (process.env.NODE_ENV !== 'production') {
                if (!this.warnings[MODULE_WARNING.MODULE_ALREADY_LOADED].includes(id)) {
                    this.warnings[MODULE_WARNING.MODULE_ALREADY_LOADED].push(id);
                }
                if (this.isAppMounted) {
                    this.logMessage('warning', `${MODULE_WARNING.MODULE_ALREADY_LOADED}: ${id}`);
                }
            }
        });
    }
    getImportMetadataResolver() {
        return this.resolver;
    }
    /**
     * Gets or creates a module record for the given resolved ID and original ID.
     *
     * This function handles the complex logic of module resolution and ensures that:
     * 1. Modules loaded via different paths (aliases, direct specifiers, URLs) return the same instance
     * 2. Bundle URLs are properly resolved to their final specifier names after instantiation
     * 3. Alias mappings are maintained for future lookups
     *
     * @param resolvedId - The resolved module identifier (could be a URL or specifier)
     * @param originalId - The original module specifer that was requested
     * @returns Promise<ModuleRecord> - The module record for the module
     */
    async getModuleRecord(resolvedId, originalId) {
        // Step 1: Check if we already have a module record for the resolved ID
        const existingRecord = this.moduleRegistry.get(resolvedId);
        if (existingRecord) {
            if (isUrl(resolvedId)) {
                // Special case: The resolved ID is a URL (likely a bundle URL)
                // We need to wait for instantiation to complete, then re-resolve to get the final specifier
                const moduleDef = await existingRecord.instantiation;
                const reResolvedId = await this.resolve(originalId);
                // If the re-resolved ID is still a URL OR matches the module definition name,
                // then this is an internally mapped module (e.g., bundle -> specifier)
                if (isUrl(reResolvedId) || moduleDef.name === reResolvedId) {
                    // Store the alias mapping and return the existing record
                    this.storeModuleAlias(originalId, reResolvedId);
                    return existingRecord;
                }
                else {
                    // The re-resolved ID is now a specifier, check if we have a record for it
                    resolvedId = reResolvedId;
                    const reExistingRecord = this.moduleRegistry.get(resolvedId);
                    if (reExistingRecord) {
                        // Found a record for the specifier, store alias and return it
                        this.storeModuleAlias(originalId, reResolvedId);
                        return reExistingRecord;
                    }
                }
            }
            else if (existingRecord) {
                // Simple case: resolved ID is a specifier and we have a record for it
                this.storeModuleAlias(originalId, resolvedId);
                return existingRecord;
            }
        }
        // Step 2: Check if the original ID is a known alias that maps to an existing module
        if (resolvedId !== originalId) {
            const alias = this.aliases.get(originalId);
            if (alias) {
                const aliasedModule = this.moduleRegistry.get(alias);
                if (aliasedModule) {
                    // Found an existing module via alias, return it
                    return aliasedModule;
                }
            }
        }
        // Step 3: No existing record found, create a new module record
        const instantiation = this.getModuleDef(resolvedId, originalId);
        // Create dependency records for all module dependencies
        const dependencyRecords = instantiation.then((moduleDef) => {
            const dependencies = moduleDef.dependencies || [];
            // Map dependencies to module records, filtering out 'exports' and 'require'
            const filtered = dependencies
                .map((dep) => {
                if (dep === 'exports') {
                    return; // 'exports' is a special AMD dependency, not a real module
                }
                invariant(dep !== 'require', NO_AMD_REQUIRE); // 'require' is not allowed
                return this.getModuleDependencyRecord.call(this, dep);
            })
                .filter((depRecord) => depRecord !== undefined);
            return Promise.all(filtered);
        });
        // Create the new module record
        const newModuleRecord = {
            id: resolvedId,
            originalId: originalId,
            module: Object.create(null),
            dependencyRecords,
            instantiation,
            evaluated: false,
            evaluationPromise: null, // Promise for module evaluation
        };
        // Store the module record and create alias mapping
        this.moduleRegistry.set(resolvedId, newModuleRecord);
        if (resolvedId !== originalId) {
            this.storeModuleAlias(originalId, resolvedId);
        }
        // Wait for dependencies to resolve before returning the module record
        return dependencyRecords.then(() => newModuleRecord);
    }
    storeModuleAlias(aliasId, resolvedId) {
        if (aliasId !== resolvedId) {
            if (!this.aliases.has(aliasId)) {
                this.aliases.set(aliasId, resolvedId);
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
            }
            else if (process.env.NODE_ENV !== 'production' && hasConsole) {
                // Warn the user if they were not aliasing to the resolvedId
                const currentResolvedId = this.aliases.get(aliasId);
                if (currentResolvedId !== resolvedId) {
                    const warningMsg = `${aliasId}=>${currentResolvedId}, ${resolvedId}`;
                    if (!this.warnings[MODULE_WARNING.ALIAS_UPDATE].includes(warningMsg)) {
                        this.warnings[MODULE_WARNING.ALIAS_UPDATE].push(warningMsg);
                    }
                    if (this.isAppMounted) {
                        this.logMessage('warning', `${MODULE_WARNING.ALIAS_UPDATE}: ${warningMsg}`);
                    }
                }
            }
        }
    }
    async getModuleDependencyRecord(dependency) {
        // Initially resolve the dependency to get its ID, which may be a bundle URL.
        let resolvedDepId = await this.resolve(dependency);
        // If the resolved dependency ID is a URL, it indicates that the dependency
        // is provided by a bundle that hasn't been fully instantiated yet.
        if (isUrl(resolvedDepId)) {
            // Retrieve the module record corresponding to the bundle URL.
            const existingRecord = this.moduleRegistry.get(resolvedDepId);
            // If a module record for the bundle exists and we haven't already created an alias for this dependency,
            // then the bundle is still pending instantiation.
            if (existingRecord && !this.aliases.has(dependency)) {
                // Wait for the bundle's instantiation promise to resolve.
                await existingRecord.instantiation;
                // After instantiation, re-resolve the dependency.
                // This should now return the final alias (the logical module ID) instead of the raw bundle URL.
                resolvedDepId = await this.resolve(dependency);
            }
        }
        return this.getModuleRecord(resolvedDepId, dependency);
    }
    // execute the "top-level code" (the code outside of functions) of a module
    async topLevelEvaluation(moduleRecord) {
        return this.evaluateModule(moduleRecord, {});
    }
    async evaluateModule(moduleRecord, evaluationMap) {
        const dependencyModuleRecords = await moduleRecord.dependencyRecords;
        if (dependencyModuleRecords.length > 0) {
            evaluationMap[moduleRecord.id] = true;
            // evaluate dependencies first
            await this.evaluateModuleDependencies(dependencyModuleRecords, evaluationMap);
        }
        const { exporter, dependencies } = await moduleRecord.instantiation;
        // The exports object automatically gets filled in by the exporter evaluation
        const exports = {};
        const depsMapped = dependencies
            ? await Promise.all(dependencies.map(async (dep) => {
                if (dep === 'exports') {
                    return exports;
                }
                const resolvedDepId = await this.resolve(dep);
                const moduleRecord = this.moduleRegistry.get(resolvedDepId);
                if (!moduleRecord) {
                    throw new LoaderError(FAILED_DEP, [resolvedDepId]);
                }
                const module = moduleRecord.module;
                /**
                 * Circular dependencies are handled properly when named exports are used,
                 * however, for default exports there is a bug: https://github.com/rollup/rollup/issues/3384
                 *
                 * The workaround below applies for circular dependencies (!moduleRecord.evaluated)
                 */
                if (!moduleRecord.evaluated) {
                    return this.getCircularDependencyWrapper(module);
                }
                if (module) {
                    return module.__defaultInterop ? module.default : module;
                }
                throw new LoaderError(FAILED_DEP, [resolvedDepId]);
            }))
            : [];
        // W-10029836 - In the case where we could be instantiating multiple graphs at the same time lets make sure the module have not already been evaluated
        if (moduleRecord.evaluated) {
            return moduleRecord.module;
        }
        // evaluates the module function
        let moduleDefault;
        try {
            moduleDefault = exporter(...depsMapped);
        }
        catch (e) {
            throw new LoaderError(EXPORTER_ERROR, [moduleRecord.id, e.message || e]);
        }
        // value is returned from exporter, then we are not using named exports
        if (moduleDefault !== undefined) {
            moduleDefault = { default: moduleDefault };
            // __defaultInterop is ONLY used to support backwards compatibility
            // of importing default exports the "wrong" way (when not using named exports).
            // See https://github.com/salesforce-experience-platform-emu/lwr/pull/816
            Object.defineProperty(moduleDefault, '__defaultInterop', { value: true });
        }
        // if no return value, then we are using the exports object
        else {
            // handle only default export with Rollup forced named exports
            if (this.isNamedExportDefaultOnly(exports)) {
                Object.defineProperty(exports, '__useDefault', { value: true });
            }
        }
        const moduleExports = moduleDefault || exports;
        // update the module record
        // copy over enumerable public methods to module
        for (const key in moduleExports) {
            Object.defineProperty(moduleRecord.module, key, {
                enumerable: true,
                set(value) {
                    moduleExports[key] = value;
                },
                get() {
                    return moduleExports[key];
                },
            });
        }
        // copy non-enumerable to module
        if (moduleExports.__useDefault) {
            Object.defineProperty(moduleRecord.module, '__useDefault', { value: true });
        }
        if (moduleExports.__defaultInterop) {
            Object.defineProperty(moduleRecord.module, '__defaultInterop', { value: true });
        }
        if (moduleExports.__esModule) {
            Object.defineProperty(moduleRecord.module, '__esModule', { value: true });
        }
        moduleRecord.evaluated = true;
        Object.freeze(moduleRecord.module);
        return moduleRecord.module;
    }
    // Determines if named exports module has only default export
    isNamedExportDefaultOnly(exports) {
        return (exports !== undefined &&
            Object.getOwnPropertyNames(exports).length === 2 &&
            Object.prototype.hasOwnProperty.call(exports, 'default') &&
            Object.prototype.hasOwnProperty.call(exports, '__esModule'));
    }
    // Wrap the dependency in a function that can be called and detected by __circular__ property.
    // The LWC engine checks for __circular__ to detect circular dependencies.
    getCircularDependencyWrapper(module) {
        const tmp = () => {
            return module.__useDefault || module.__defaultInterop ? module.default : module;
        };
        tmp.__circular__ = true;
        return tmp;
    }
    async evaluateModuleDependencies(dependencyModuleRecords, evaluationMap) {
        for (let i = 0; i < dependencyModuleRecords.length; i++) {
            const depRecord = dependencyModuleRecords[i];
            if (!depRecord.evaluated && !evaluationMap[depRecord.id]) {
                evaluationMap[depRecord.id] = true;
                // eslint-disable-next-line no-await-in-loop
                await this.evaluateModule(depRecord, evaluationMap);
            }
        }
    }
    async getModuleDef(resolvedId, originalId) {
        // reset lastDefine
        this.lastDefine = undefined;
        // the module name can be the resolved ID or the original ID if neither are URL's.
        const moduleName = !isUrl(resolvedId)
            ? resolvedId
            : originalId !== resolvedId
                ? originalId
                : undefined;
        let moduleDef = moduleName && this.namedDefineRegistry.get(moduleName);
        if (moduleDef && moduleDef.external) {
            return moduleDef.external.moduleDefPromise;
        }
        if (moduleDef && moduleDef.defined) {
            return moduleDef;
        }
        const parentUrl = this.resolver.getBaseUrl(); // only support baseUrl for now
        const specifier = moduleName || originalId;
        this.profiler.logOperationStart({ id: MODULE_FETCH, specifier });
        return Promise.resolve()
            .then(async () => {
            const loadHooks = this.loadHook;
            if (loadHooks) {
                for (let i = 0; i < loadHooks.length; i++) {
                    const loadHook = loadHooks[i];
                    const response = loadHook(resolvedId, parentUrl);
                    const result = (isResponseAPromise(response)
                        ? // eslint-disable-next-line no-await-in-loop
                            await evaluateLoadHook(resolvedId, response)
                        : response);
                    if (result === undefined) {
                        throw new LoaderError(INVALID_LOADER_SERVICE_RESPONSE);
                    }
                    if (result && result !== null) {
                        return evaluateLoadHookResponse(result, resolvedId);
                    }
                }
            }
            return false;
        })
            .then((result) => {
            if (result !== true && hasDocument) {
                return loadModuleDef(resolvedId);
            }
        })
            .then(() => {
            // Attempt to retrieve the module definition by name first
            moduleDef = moduleName && this.namedDefineRegistry.get(moduleName);
            // Fallback to the last loader.define call
            if (!moduleDef) {
                this.logMessage('warning', `${moduleName} not found, falling back to the last loader.define call`);
                moduleDef = this.lastDefine;
            }
            // This should not happen
            if (!moduleDef) {
                throw new LoaderError(FAIL_INSTANTIATE, [resolvedId]);
            }
            this.profiler.logOperationEnd({ id: MODULE_FETCH, specifier });
            return moduleDef;
        })
            .catch((e) => {
            // Create module error marks for all errors caused by the loader
            // Note: these marks do not include errors caused by invalid server responses or loader hooks
            if (!(e instanceof LoaderError)) {
                this.profiler.logOperationStart({ id: MODULE_ERROR, specifier });
            }
            throw e;
        });
    }
    addLoaderPlugin(hooks) {
        if (typeof hooks !== 'object') {
            throw new LoaderError(INVALID_HOOK);
        }
        const { loadModule: loadHook, resolveModule: resolveHook, loadMapping } = hooks;
        if (resolveHook) {
            if (this.resolveHook) {
                this.resolveHook.push(resolveHook);
            }
            else {
                this.resolveHook = [resolveHook];
            }
        }
        if (loadHook) {
            if (this.loadHook) {
                this.loadHook.push(loadHook);
            }
            else {
                this.loadHook = [loadHook];
            }
        }
        if (loadMapping) {
            this.resolver.addLoadMappingHook(loadMapping);
        }
    }
    importMetadataInvalidationCallback({ name, oldUrl, newUrl }) {
        const handleStaleModuleHooks = this.handleStaleModuleHook;
        if (handleStaleModuleHooks) {
            evaluateHandleStaleModuleHooks(handleStaleModuleHooks, {
                name,
                oldUrl,
                newUrl,
            });
        }
        else {
            // eslint-disable-next-line lwr/no-unguarded-apis
            if (process.env.NODE_ENV !== 'production' && hasConsole) {
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                console.warn(`stale module detected ${name}, current URL:${oldUrl}, new URL:${newUrl}`);
            }
        }
    }
    registerHandleStaleModuleHook(handleStaleModule) {
        if (this.handleStaleModuleHook) {
            this.handleStaleModuleHook.push(handleStaleModule);
        }
        else {
            this.handleStaleModuleHook = [handleStaleModule];
        }
    }
    isValidResolveResponse(res) {
        return (res === null || typeof res === 'string' || (res && typeof res.url === 'string'));
    }
    getModuleWarnings(isAppMounted = false) {
        this.isAppMounted = isAppMounted;
        return this.warnings;
    }
    logMessage(logType, message) {
        if (!hasConsole ||
            // note: we always expect this to be replaced at build time
            // eslint-disable-next-line lwr/no-unguarded-apis
            process.env.NODE_ENV === 'production') {
            return;
        }
        if (logType == 'warning') {
            // eslint-disable-next-line lwr/no-unguarded-apis
            console.warn(message);
        }
        else {
            // eslint-disable-next-line lwr/no-unguarded-apis
            console.log(message);
        }
    }
}
//# sourceMappingURL=moduleRegistry.js.map