/**
* Copyright (c) 2021, salesforce.com, inc.
* All rights reserved.
* SPDX-License-Identifier: MIT
* For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
*/
/* LWR Module Loader Shim v0.21.4 */
(function () {
  'use strict';

  // Bootstrap / shim
  const BOOTSTRAP_PREFIX = 'lwr.bootstrap.';
  const BOOTSTRAP_ERROR = `${BOOTSTRAP_PREFIX}error`;

  var Phase = /*#__PURE__*/function (Phase) {
    Phase[Phase["Start"] = 0] = "Start";
    Phase[Phase["End"] = 1] = "End";
    return Phase;
  }(Phase || {});
  // Attach a custom dispatcher
  let customDispatcher;
  function attachDispatcher(dispatcher) {
    customDispatcher = dispatcher;
  }

  // Check if the Performance API is available
  // e.g. JSDom (used in Jest) doesn't implement these
  // eslint-disable-next-line
  const perf = globalThis.performance;
  const isPerfSupported = typeof perf !== 'undefined' && typeof perf.mark === 'function' && typeof perf.clearMarks === 'function' && typeof perf.measure === 'function' && typeof perf.clearMeasures === 'function';
  function getMeasureName(id, specifier) {
    return specifier ? `${id}-${specifier}` : id;
  }
  function getMarkName(id, specifier, specifierIndex) {
    const measureName = getMeasureName(id, specifier);
    return specifier && specifierIndex ? `${measureName}_${specifierIndex}` : measureName;
  }
  function getDetail(specifier, metadata) {
    const detail = specifier || metadata ? {
      ...metadata
    } : null;
    if (detail && specifier) {
      detail['specifier'] = specifier;
    }
    return detail;
  }

  // For marking request metrics
  // Fallback to the Performance API if there is no custom dispatcher
  function logOperationStart({
    id,
    specifier,
    specifierIndex,
    metadata
  }) {
    if (customDispatcher) {
      customDispatcher({
        id,
        phase: Phase.Start,
        specifier,
        metadata,
        specifierIndex
      });
      return;
    }
    if (isPerfSupported) {
      const markName = getMarkName(id, specifier, specifierIndex);
      const detail = getDetail(specifier, metadata);
      perf.mark(markName, {
        detail
      });
    }
  }

  // For measuring duration metrics
  // Fallback to the Performance API if there is no custom dispatcher
  /* istanbul ignore next */
  function logOperationEnd({
    id,
    specifier,
    specifierIndex,
    metadata
  }) {
    if (customDispatcher) {
      customDispatcher({
        id,
        phase: Phase.End,
        specifier,
        metadata,
        specifierIndex
      });
    } else if (isPerfSupported) {
      const markName = getMarkName(id, specifier, specifierIndex);
      const measureName = getMeasureName(id, specifier);
      const detail = getDetail(specifier, metadata);
      perf.measure(measureName, {
        start: markName,
        detail
      });

      // Clear the created mark and measure to avoid filling the performance entry buffer
      // Even if they get deleted, existing PerformanceObservers preserve copies of the entries
      perf.clearMarks(markName);
      perf.clearMeasures(measureName);
    }
  }

  function createLoader(
      name,
      definition,
      config,
      externalModules,
  ) {
      if (!definition || typeof definition[2] !== 'function') {
          throw new Error(`Expected loader with specifier "${name}" to be a module`);
      }

      // Create a Loader instance
      const exports = {};
      definition[2].call(null, exports);
      const { Loader } = exports;
      if (!Loader) {
          throw new Error('Expected Loader class to be defined');
      }
      const loader = new Loader(config);

      if (externalModules && externalModules.length) {
          loader.registerExternalModules(externalModules);
      }

      // Define the loader module with public API: { define, load, services }
      const exporter = (exports) => {
          Object.assign(exports, {
              define: loader.define.bind(loader),
              load: loader.load.bind(loader),
              services: loader.services,
          });
      };
      loader.define(name, ['exports'], exporter);

      return loader;
  }

  const REQUIRED_MODULES_TIMEOUT = 60 * 1000; // 2m

  // Check for errors with autoBoot and customInit
  function validatePreInit(autoBoot, customInit) {
      // If autoBoot === false, there must be a customInit hook
      if (!autoBoot && !customInit) {
          throw new Error('The customInit hook is required when autoBoot is false');
      }
      // If autoBoot === true, there must NOT be a customInit hook
      if (autoBoot && customInit) {
          throw new Error('The customInit hook must not be defined when autoBoot is true');
      }
  }

  // Process the customInit hook
  function customInit(
      config,
      initializeApp,
      define,
      onBootstrapError,
  ) {
      // Validate config
      const { autoBoot, customInit } = config;
      validatePreInit(autoBoot, customInit);

      // Set up arguments and call the customInit hook, if available
      if (customInit) {
          const lwr = {
              initializeApp,
              define,
              onBootstrapError,
              attachDispatcher,
          };
          customInit(lwr, config);
      }
  }

  /* global document, process, console */









  /* eslint-disable lwr/no-unguarded-apis */
  const hasSetTimeout = typeof setTimeout === 'function';
  const hasConsole = typeof console !== 'undefined';
  const hasProcess = typeof process !== 'undefined';
  /* eslint-enable lwr/no-unguarded-apis */

  class LoaderShim {
      
      
      
      
       __init() {this.defineCache = {};}
       __init2() {this.orderedDefs = [];}
      
       // eslint-disable-line no-undef, lwr/no-unguarded-apis
      

      constructor(global) {LoaderShim.prototype.__init.call(this);LoaderShim.prototype.__init2.call(this);
          // Start watchdog timer
          if (hasSetTimeout) {
              this.watchdogTimerId = this.startWatchdogTimer();
          }

          // Parse configuration
          this.global = global;
          this.config = global.LWR ;
          this.loaderSpecifier = 'lwr/loader/v/0_21_4';

          // Set up error handler
          this.errorHandler = this.config.onError ;

          // Set up onAppInit handler
          this.initAppHandler = this.config.onInitApp ;

          // Set up the temporary LWR.define function and customInit hook
          const tempDefine = this.tempDefine.bind(this);
          global.LWR.define = tempDefine;
          this.bootReady = this.config.autoBoot;

          try {
              this.createProfilerModule(global.LWR.define);
              customInit(
                  Object.freeze(this.config),
                  this.postCustomInit.bind(this),
                  tempDefine,
                  (e) => {
                      // customInit handlers can overwrite
                      // the error handler with onBootstrapError
                      this.errorHandler = e;
                  },
              );
          } catch (e) {
              this.enterErrorState(e);
          }
      }

      // Return true if the app can be initialized
       canInit() {
          if (!this.config.requiredModules) {
              throw new Error('Unexpected missing requiredModules');
          }
          // Initialize the app if:
          //  - bootReady: autoBoot is on OR customInit has finished
          //  - all required modules are defined
          const allDefined = this.config.requiredModules.every((m) => this.orderedDefs.includes(m));
          return this.bootReady && allDefined;
      }

      /**
       * Create a temporary LWR.define() function which captures all
       * calls that occur BEFORE the full loader module is available
       *
       * Each call to LWR.define() is stored in 2 ways:
       *      - in a map as [moduleName, arguments] pairs
       *      - each moduleName is pushed onto an array, to preserve
       *          the order in which the modules were defined
       */
       tempDefine(...args) {
          // Cache the incoming module
          const moduleName = args[0];
          this.defineCache[moduleName] = args;
          this.orderedDefs.push(moduleName);
          if (this.canInit()) {
              if (hasSetTimeout) {
                  // requiredModules are defined, clear watchdog timer
                  // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                  clearTimeout(this.watchdogTimerId);
              }
              this.initApp();
          }
      }

      // Called by the customInit hook via lwr.initializeApp()
       postCustomInit() {
          this.bootReady = true;
          if (this.canInit()) {
              if (hasSetTimeout) {
                  // requiredModules are defined, clear watchdog timer
                  // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                  clearTimeout(this.watchdogTimerId);
              }
              this.initApp();
          }
      }

      // Create the loader and initialize the application
       initApp() {
          try {
              if (this.initAppHandler) {
                  this.initAppHandler();
              }
          } catch (e) {
              // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
              console.error(`An error occurred in the onInitApp function. ${e.message}`, e.stack);
          }
          try {
              const loaderConfig = {
                  endpoints: this.config.endpoints,
                  baseUrl: this.config.baseUrl,
                  flags: this.config.flags,
                  profiler: { logOperationStart, logOperationEnd },
                  // TODO: can be removed following https://github.com/salesforce-experience-platform-emu/lwr/issues/1087
                  appMetadata: {
                      appId: this.config.appId,
                      bootstrapModule: this.config.bootstrapModule,
                      rootComponent: this.config.rootComponent,
                      rootComponents: this.config.rootComponents,
                  },
              };
              const loader = createLoader(
                  this.loaderSpecifier,
                  this.defineCache[this.loaderSpecifier],
                  loaderConfig,
                  this.config.preloadModules,
              );
              this.mountApp(loader);
              if (
                  loader &&
                  typeof loader.getModuleWarnings === 'function' &&
                  hasProcess &&
                  hasConsole &&
                  // eslint-disable-next-line lwr/no-unguarded-apis
                  process.env.NODE_ENV !== 'production'
              ) {
                  this.logWarnings(loader.getModuleWarnings(true)); // the true indicates the app is mounted
              }
          } catch (e) {
              this.enterErrorState(e);
          }
      }

       waitForBody() {
          return new Promise((resolve) => {
              // eslint-disable-next-line lwr/no-unguarded-apis
              if (document.body) {
                  resolve();
              } else {
                  const observer = new MutationObserver(() => {
                      // eslint-disable-next-line lwr/no-unguarded-apis
                      if (document.body) {
                          observer.disconnect();
                          resolve();
                      }
                  });
                  observer.observe(document.documentElement, { childList: true });
              }
          });
      }

       waitForDOMContentLoaded() {
          // Resolve if document is already "ready" https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState
          // eslint-disable-next-line lwr/no-unguarded-apis
          if (document.readyState === 'interactive' || document.readyState === 'complete') {
              return Promise.resolve();
          }
          return new Promise((resolve) => {
              // eslint-disable-next-line lwr/no-unguarded-apis
              document.addEventListener('DOMContentLoaded', () => {
                  resolve();
              });
          });
      }

      // Create a module out of the profiler
      // Note: The profiler is also available as a module through lwc module resolution (see package.json)
       createProfilerModule(define) {
          const exporter = (exports) => {
              Object.assign(exports, { logOperationStart, logOperationEnd });
          };
          define('lwr/profiler/v/0_21_4', ['exports'], exporter);
      }

      // Set up the application globals, import map, root custom element...
       mountApp(loader) {
          const { bootstrapModule, rootComponent, rootComponents, serverData, endpoints, imports, index } =
              this.config;

          const importsObj = imports || {};
          // Set global LWR.define to loader.define
          this.global.LWR = Object.freeze({
              define: loader.define.bind(loader),
              rootComponent,
              rootComponents,
              serverData: serverData || {},
              endpoints,
              imports: importsObj,
              index: index || {},
              env: this.global.LWR.env,
          });

          // Redefine all modules in the temporary cache
          this.orderedDefs.forEach((specifier) => {
              if (specifier !== this.loaderSpecifier) {
                  loader.define(...this.defineCache[specifier]);
              }
          });

          // by default, app initialization is gated on waiting for body to be available
          // this flag uses the DOMContentLoaded event instead
          const { initDeferDOM } = this.config;

          // Load the import mappings and application bootstrap module
          loader
              .registerImportMappings({ imports: importsObj, index }, [
                  bootstrapModule,
                  rootComponent ,
              ])
              .then(() => {
                  // eslint-disable-next-line lwr/no-unguarded-apis
                  if (typeof window === 'undefined' || typeof document === undefined) {
                      return Promise.resolve();
                  }
                  if (initDeferDOM) {
                      return this.waitForDOMContentLoaded();
                  }
                  return this.waitForBody();
              })
              .then(() => loader.load(bootstrapModule))
              .catch((reason) => {
                  this.enterErrorState(
                      new Error(
                          `Application ${rootComponent || bootstrapModule} could not be loaded: ${reason}`,
                      ),
                  );
              });
      }

      // Trigger bootstrap error state, and call error handler if registered
       enterErrorState(error) {
          logOperationStart({ id: BOOTSTRAP_ERROR });
          if (this.errorHandler) {
              this.errorHandler(error);
          } else {
              if (hasConsole) {
                  // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                  console.error(`An error occurred during LWR bootstrap. ${error.message}`, error.stack);
              }
          }
      }

      // eslint-disable-next-line no-undef, lwr/no-unguarded-apis
       startWatchdogTimer() {
          // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
          return setTimeout(() => {
              const requiredModulesMissing =
                  (this.config.requiredModules &&
                      this.config.requiredModules.filter((element) => !this.orderedDefs.includes(element))) ||
                  [];
              this.enterErrorState(
                  new Error(
                      `Failed to load required modules - timed out: ${requiredModulesMissing.join(', ')}`,
                  ),
              );
          }, REQUIRED_MODULES_TIMEOUT);
      }

       logWarnings(warnings) {
          for (const warningKey in warnings) {
              if (warnings[warningKey].length) {
                  // eslint-disable-next-line lwr/no-unguarded-apis
                  console.warn(warningKey, warnings[warningKey]);
              }
          }
      }
  }

  // The loader module is ALWAYS required
  const GLOBAL = globalThis ;
  GLOBAL.LWR.requiredModules = GLOBAL.LWR.requiredModules || [];
  if (GLOBAL.LWR.requiredModules.indexOf('lwr/loader/v/0_21_4') < 0) {
      GLOBAL.LWR.requiredModules.push('lwr/loader/v/0_21_4');
  }
  new LoaderShim(GLOBAL);

})();
