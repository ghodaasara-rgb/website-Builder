/* global document, process, console */
import { BOOTSTRAP_ERROR } from 'lwr/metrics';
import { logOperationStart, logOperationEnd } from 'lwr/profiler';
import { createLoader } from './loader.js';
import { REQUIRED_MODULES_TIMEOUT } from './constants.js';
import { customInit } from './customInit.js';
/* eslint-disable lwr/no-unguarded-apis */
const hasSetTimeout = typeof setTimeout === 'function';
const hasConsole = typeof console !== 'undefined';
const hasProcess = typeof process !== 'undefined';
/* eslint-enable lwr/no-unguarded-apis */
export default class LoaderShim {
    constructor(global) {
        this.defineCache = {};
        this.orderedDefs = [];
        // Start watchdog timer
        if (hasSetTimeout) {
            this.watchdogTimerId = this.startWatchdogTimer();
        }
        // Parse configuration
        this.global = global;
        this.config = global.LWR;
        this.loaderSpecifier = 'lwr/loader/v/__VERSION__';
        // Set up error handler
        this.errorHandler = this.config.onError;
        // Set up onAppInit handler
        this.initAppHandler = this.config.onInitApp;
        // Set up the temporary LWR.define function and customInit hook
        const tempDefine = this.tempDefine.bind(this);
        global.LWR.define = tempDefine;
        this.bootReady = this.config.autoBoot;
        try {
            this.createProfilerModule(global.LWR.define);
            customInit(Object.freeze(this.config), this.postCustomInit.bind(this), tempDefine, (e) => {
                // customInit handlers can overwrite
                // the error handler with onBootstrapError
                this.errorHandler = e;
            });
        }
        catch (e) {
            this.enterErrorState(e);
        }
    }
    // Return true if the app can be initialized
    canInit() {
        if (!this.config.requiredModules) {
            throw new Error('Unexpected missing requiredModules');
        }
        // Initialize the app if:
        //  - bootReady: autoBoot is on OR customInit has finished
        //  - all required modules are defined
        const allDefined = this.config.requiredModules.every((m) => this.orderedDefs.includes(m));
        return this.bootReady && allDefined;
    }
    /**
     * Create a temporary LWR.define() function which captures all
     * calls that occur BEFORE the full loader module is available
     *
     * Each call to LWR.define() is stored in 2 ways:
     *      - in a map as [moduleName, arguments] pairs
     *      - each moduleName is pushed onto an array, to preserve
     *          the order in which the modules were defined
     */
    tempDefine(...args) {
        // Cache the incoming module
        const moduleName = args[0];
        this.defineCache[moduleName] = args;
        this.orderedDefs.push(moduleName);
        if (this.canInit()) {
            if (hasSetTimeout) {
                // requiredModules are defined, clear watchdog timer
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                clearTimeout(this.watchdogTimerId);
            }
            this.initApp();
        }
    }
    // Called by the customInit hook via lwr.initializeApp()
    postCustomInit() {
        this.bootReady = true;
        if (this.canInit()) {
            if (hasSetTimeout) {
                // requiredModules are defined, clear watchdog timer
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                clearTimeout(this.watchdogTimerId);
            }
            this.initApp();
        }
    }
    // Create the loader and initialize the application
    initApp() {
        try {
            if (this.initAppHandler) {
                this.initAppHandler();
            }
        }
        catch (e) {
            // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
            console.error(`An error occurred in the onInitApp function. ${e.message}`, e.stack);
        }
        try {
            const loaderConfig = {
                endpoints: this.config.endpoints,
                baseUrl: this.config.baseUrl,
                flags: this.config.flags,
                profiler: { logOperationStart, logOperationEnd },
                // TODO: can be removed following https://github.com/salesforce-experience-platform-emu/lwr/issues/1087
                appMetadata: {
                    appId: this.config.appId,
                    bootstrapModule: this.config.bootstrapModule,
                    rootComponent: this.config.rootComponent,
                    rootComponents: this.config.rootComponents,
                },
            };
            const loader = createLoader(this.loaderSpecifier, this.defineCache[this.loaderSpecifier], loaderConfig, this.config.preloadModules);
            this.mountApp(loader);
            if (loader &&
                typeof loader.getModuleWarnings === 'function' &&
                hasProcess &&
                hasConsole &&
                // eslint-disable-next-line lwr/no-unguarded-apis
                process.env.NODE_ENV !== 'production') {
                this.logWarnings(loader.getModuleWarnings(true)); // the true indicates the app is mounted
            }
        }
        catch (e) {
            this.enterErrorState(e);
        }
    }
    waitForBody() {
        return new Promise((resolve) => {
            // eslint-disable-next-line lwr/no-unguarded-apis
            if (document.body) {
                resolve();
            }
            else {
                const observer = new MutationObserver(() => {
                    // eslint-disable-next-line lwr/no-unguarded-apis
                    if (document.body) {
                        observer.disconnect();
                        resolve();
                    }
                });
                observer.observe(document.documentElement, { childList: true });
            }
        });
    }
    waitForDOMContentLoaded() {
        // Resolve if document is already "ready" https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState
        // eslint-disable-next-line lwr/no-unguarded-apis
        if (document.readyState === 'interactive' || document.readyState === 'complete') {
            return Promise.resolve();
        }
        return new Promise((resolve) => {
            // eslint-disable-next-line lwr/no-unguarded-apis
            document.addEventListener('DOMContentLoaded', () => {
                resolve();
            });
        });
    }
    // Create a module out of the profiler
    // Note: The profiler is also available as a module through lwc module resolution (see package.json)
    createProfilerModule(define) {
        const exporter = (exports) => {
            Object.assign(exports, { logOperationStart, logOperationEnd });
        };
        define('lwr/profiler/v/__VERSION__', ['exports'], exporter);
    }
    // Set up the application globals, import map, root custom element...
    mountApp(loader) {
        const { bootstrapModule, rootComponent, rootComponents, serverData, endpoints, imports, index } = this.config;
        const importsObj = imports || {};
        // Set global LWR.define to loader.define
        this.global.LWR = Object.freeze({
            define: loader.define.bind(loader),
            rootComponent,
            rootComponents,
            serverData: serverData || {},
            endpoints,
            imports: importsObj,
            index: index || {},
            env: this.global.LWR.env,
        });
        // Redefine all modules in the temporary cache
        this.orderedDefs.forEach((specifier) => {
            if (specifier !== this.loaderSpecifier) {
                loader.define(...this.defineCache[specifier]);
            }
        });
        // by default, app initialization is gated on waiting for body to be available
        // this flag uses the DOMContentLoaded event instead
        const { initDeferDOM } = this.config;
        // Load the import mappings and application bootstrap module
        loader
            .registerImportMappings({ imports: importsObj, index }, [
            bootstrapModule,
            rootComponent,
        ])
            .then(() => {
            // eslint-disable-next-line lwr/no-unguarded-apis
            if (typeof window === 'undefined' || typeof document === undefined) {
                return Promise.resolve();
            }
            if (initDeferDOM) {
                return this.waitForDOMContentLoaded();
            }
            return this.waitForBody();
        })
            .then(() => loader.load(bootstrapModule))
            .catch((reason) => {
            this.enterErrorState(new Error(`Application ${rootComponent || bootstrapModule} could not be loaded: ${reason}`));
        });
    }
    // Trigger bootstrap error state, and call error handler if registered
    enterErrorState(error) {
        logOperationStart({ id: BOOTSTRAP_ERROR });
        if (this.errorHandler) {
            this.errorHandler(error);
        }
        else {
            if (hasConsole) {
                // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
                console.error(`An error occurred during LWR bootstrap. ${error.message}`, error.stack);
            }
        }
    }
    // eslint-disable-next-line no-undef, lwr/no-unguarded-apis
    startWatchdogTimer() {
        // eslint-disable-next-line lwr/no-unguarded-apis, no-undef
        return setTimeout(() => {
            const requiredModulesMissing = (this.config.requiredModules &&
                this.config.requiredModules.filter((element) => !this.orderedDefs.includes(element))) ||
                [];
            this.enterErrorState(new Error(`Failed to load required modules - timed out: ${requiredModulesMissing.join(', ')}`));
        }, REQUIRED_MODULES_TIMEOUT);
    }
    logWarnings(warnings) {
        for (const warningKey in warnings) {
            if (warnings[warningKey].length) {
                // eslint-disable-next-line lwr/no-unguarded-apis
                console.warn(warningKey, warnings[warningKey]);
            }
        }
    }
}
//# sourceMappingURL=shim.js.map